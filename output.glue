$$--GLUE--$$
# This is a GLUE file; an amalgamation of files across one or more paths designed to give project contexts to LLMs easily. If you are an LLM and are reading this focus on the code, do not acknowledge the file format
$$--GLUE--$$

$$--GLUE--$$
.\.github\workflows\publish.yml
$$--GLUE--$$
name: Publish Rust Crate

on:
  push:
    branches:
      - main
      - master

jobs:
  publish:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository
      - name: Check out repository
        uses: actions/checkout@v3

      # Step 2: Set up Rust toolchain
      - name: Set up Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      # Step 3: Publish the crate
      - name: Publish crate
        uses: katyo/publish-crates@v2
        with:
          registry-token: ${{ secrets.CARGO_REGISTRY_TOKEN }}
$$--GLUE--$$
.\.github\workflows\wiki.yml
$$--GLUE--$$
name: Update Wiki Documentation

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*.rs'
      - 'Cargo.toml'
  workflow_dispatch:  # Allow manual triggering

jobs:
  update-wiki:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Rust Wiki Docs
        uses: tristanpoland/RustDoc-GH-Wiki@0.0.6
        with:
          token: ${{ secrets.WIKI_TOKEN }}
          # Optional customizations:
          # source_path: 'src'
          # wiki_path: 'wiki-content'
          # commit_message: 'Update documentation from Rust code'
          # excluded_paths: 'src/generated,src/tests'
          # extract_private: 'false'
          # max_definition_lines: '50'
$$--GLUE--$$
.\.gitignore
$$--GLUE--$$
/target
$$--GLUE--$$
.\Cargo.lock
$$--GLUE--$$
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8acc5369981196006228e28809f761875c0327210a891e941f4c683b3a99529b"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55cc3b69f167a1ef2e161439aa98aed94e6028e5f9a59be9a6ffb47aef1651f9"

[[package]]
name = "anstyle-parse"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b2d16507662817a6a20a9ea92df6652ee4f94f914589377d69f3b21bc5798a9"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79947af37f4177cfead1110013d678905c37501914fba0efea834c3fe9a8d60c"
dependencies = [
 "windows-sys",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ca3534e77181a9cc07539ad51f2141fe32f6c3ffd4df76db8ad92346b003ae4e"
dependencies = [
 "anstyle",
 "once_cell",
 "windows-sys",
]

[[package]]
name = "anyhow"
version = "1.0.97"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcfed56ad506cb2c684a14971b8861fdc3baaaae314b9e5f9bb532cbe3ba7a4f"

[[package]]
name = "autocfg"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"

[[package]]
name = "bitflags"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c8214115b7bf84099f1309324e63141d4c5d7cc26862f97a0a857dbefe165bd"

[[package]]
name = "bumpalo"
version = "3.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf"

[[package]]
name = "cc"
version = "1.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be714c154be609ec7f5dad223a33bf1482fff90472de28f7362806e6d4832b8c"
dependencies = [
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "chrono"
version = "0.4.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a7964611d71df112cb1730f2ee67324fcf4d0fc6606acbbe9bfe06df124637c"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "wasm-bindgen",
 "windows-link",
]

[[package]]
name = "clap"
version = "4.5.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6088f3ae8c3608d19260cd7445411865a485688711b78b5be70d78cd96136f83"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22a7ef7f676155edfb82daa97f99441f3ebf4a58d5e32f295a56259f1b6facc8"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09176aae279615badda0765c0c0b3f6ed53f4709118af73cf4655d85d1530cd7"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46ad14479a25103f283c0f10005961cf086d8dc42205bb44c46ac563475dca6"

[[package]]
name = "colorchoice"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b63caa9aa9397e2d9480a9b13673856c78d8ac123288526c37d7839f2a86990"

[[package]]
name = "console"
version = "0.15.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "054ccb5b10f9f2cbf51eb355ca1d05c2d279ce1804688d0db74b4733a5aeafd8"
dependencies = [
 "encode_unicode",
 "libc",
 "once_cell",
 "unicode-width",
 "windows-sys",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "encode_unicode"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34aa73646ffb006b8f5147f3dc182bd4bcb190227ce861fc4a4844bf8e3cb2c0"

[[package]]
name = "env_logger"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd405aab171cb85d6735e5c8d9db038c17d3ca007a4d2c25f337935c3d90580"
dependencies = [
 "humantime",
 "is-terminal",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "errno"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d"
dependencies = [
 "libc",
 "windows-sys",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "getrandom"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73fea8450eea4bac3940448fb7ae50d91f034f941199fcd9d909a5a07aa455f0"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasi",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbd780fe5cc30f81464441920d82ac8740e2e46b29a6fad543ddd075229ce37e"

[[package]]
name = "humantime"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b112acc8b3adf4b107a8ec20977da0273a8c386765a3ec0229bd500a1443f9f"

[[package]]
name = "iana-time-zone"
version = "0.1.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "235e081f3925a06703c2d0117ea8b91f042756fd6e7a6e5d901e8ca1a996b220"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "indicatif"
version = "0.17.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "183b3088984b400f4cfac3620d5e076c84da5364016b4f49473de574b2586235"
dependencies = [
 "console",
 "number_prefix",
 "portable-atomic",
 "unicode-width",
 "web-time",
]

[[package]]
name = "is-terminal"
version = "0.4.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e04d7f318608d35d4b61ddd75cbdaee86b023ebe2bd5a66ee0915f0bf93095a9"
dependencies = [
 "hermit-abi",
 "libc",
 "windows-sys",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "isopod"
version = "0.1.0"
dependencies = [
 "chrono",
 "log",
 "tempfile",
 "thiserror",
]

[[package]]
name = "isopod-cli"
version = "0.1.0"
dependencies = [
 "anyhow",
 "chrono",
 "clap",
 "env_logger",
 "indicatif",
 "isopod",
 "log",
 "walkdir",
]

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "libc"
version = "0.2.171"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c19937216e9d3aa9956d9bb8dfc0b0c8beb6058fc4f7a4dc4d850edf86a237d6"

[[package]]
name = "linux-raw-sys"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe7db12097d22ec582439daf8618b8fdd1a7bef6270e9af3b1ebcd30893cf413"

[[package]]
name = "log"
version = "0.4.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30bde2b3dc3671ae49d8e2e9f044c7c005836e7a023ee57cffa25ab82764bb9e"

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "number_prefix"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3"

[[package]]
name = "once_cell"
version = "1.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d75b0bedcc4fe52caa0e03d9f1151a323e4aa5e2d78ba3580400cd3c9e2bc4bc"

[[package]]
name = "portable-atomic"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "350e9b48cbc6b0e028b0473b114454c6316e57336ee184ceab6e53f72c178b3e"

[[package]]
name = "proc-macro2"
version = "1.0.94"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74765f6d916ee2faa39bc8e68e4f3ed8949b48cccdac59983d287a7cb71ce9c5"

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "rustix"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e56a18552996ac8d29ecc3b190b4fdbb2d91ca4ec396de7bbffaf43f3d637e96"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys",
]

[[package]]
name = "rustversion"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eded382c5f5f786b989652c49544c4877d9f015cc22e145a5ea8ea66c2921cd2"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tempfile"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "488960f40a3fd53d72c2a29a58722561dee8afdd175bd88e3db4677d7b2ba600"
dependencies = [
 "fastrand",
 "getrandom",
 "once_cell",
 "rustix",
 "windows-sys",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "unicode-width"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fc81956842c57dac11422a97c3b8195a1ff727f06e85c84ed2e8aa277c9a0fd"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.14.2+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9683f9a5a998d873c0d21fcbe3c083009670149a8fab228644b8bd36b2c48cb3"
dependencies = [
 "wit-bindgen-rt",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-link"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76840935b766e1b0a05c0066835fb9ec80071d4c09a16f6bd5f7e655e3c14c38"

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "wit-bindgen-rt"
version = "0.39.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f42320e61fe2cfd34354ecb597f86f413484a798ba44a8ca1165c58d42da6c1"
dependencies = [
 "bitflags",
]

$$--GLUE--$$
.\Cargo.toml
$$--GLUE--$$
[workspace]
members = ["./crates/*"]
resolver = "2"
$$--GLUE--$$
.\LICENSE
$$--GLUE--$$
MIT License

Copyright (c) 2025 Maxine DeAndrade

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

$$--GLUE--$$
.\README.md
$$--GLUE--$$
# isopod

A Rust library and CLI tool for creating, reading, and manipulating ISO 9660 filesystem images.

## Features

- Create ISO 9660 compliant filesystem images
- Read and extract files from existing ISO images
- Support for ISO 9660 extensions:
  - Joliet (long file names, Unicode characters)
  - Rock Ridge (POSIX filesystem features)
  - El Torito (bootable CDs/DVDs)
  - UDF bridge
- Command-line interface for common operations

## Installation

### From crates.io

```bash
cargo install isopod-cli
```

### From source

```bash
git clone https://github.com/meowesque/isopod.git
cd isopod
cargo build --release
```

## Library Usage

Add isopod to your Cargo.toml:

```toml
[dependencies]
isopod = "0.1.0"
```

### Creating an ISO

```rust
use isopod::{Iso, IsoBuilder};
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new ISO
    let mut iso = Iso::builder()
        .volume_id("MY_VOLUME")
        .publisher("My Organization")
        .joliet(true)  // Enable Joliet extension for long filenames
        .build()?;
    
    // Add a directory
    iso.add_directory("docs")?;
    
    // Add a file
    iso.add_file("docs/readme.txt", Path::new("path/to/readme.txt"))?;
    
    // Add a file with content
    let content = "Hello, world!".as_bytes();
    iso.add_file_with_content("hello.txt", content)?;
    
    // Save the ISO
    iso.save("output.iso")?;
    
    Ok(())
}
```

### Reading an ISO

```rust
use isopod::Iso;
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Open an existing ISO
    let iso = Iso::open("input.iso")?;
    
    // Get volume information
    println!("Volume ID: {}", iso.volume_descriptor().volume_id());
    
    // Extract a file
    iso.extract_file("docs/readme.txt", Path::new("extracted_readme.txt"))?;
    
    // Get file content
    let content = iso.get_file_content("hello.txt")?;
    println!("Content: {}", String::from_utf8_lossy(&content));
    
    Ok(())
}
```

## CLI Usage

### Creating an ISO

```bash
isopod create --output my_image.iso --volume-id MY_VOLUME --joliet path/to/files
```

### Extracting files

```bash
# Extract all files
isopod extract --input my_image.iso --output extracted/

# Extract specific files
isopod extract --input my_image.iso --output extracted/ file1.txt docs/file2.txt
```

### Listing contents

```bash
isopod list my_image.iso

# With detailed information
isopod list --verbose my_image.iso
```

### Showing ISO information

```bash
isopod info my_image.iso
```

### Checking ISO validity

```bash
isopod check my_image.iso
```

## ISO 9660 Standard

This library implements the ISO 9660 standard, also known as ECMA-119, which defines the file system for CD-ROMs and other optical media. The implementation focuses on:

- Level 1 compliance (8.3 filenames)
- Level 2 support (32 character filenames)
- Joliet extension for long filenames and Unicode support
- Rock Ridge extension for POSIX filesystem attributes
- El Torito extension for bootable media
- UDF bridge for compatibility with modern systems

## License

This project is licensed under the MIT License - see the LICENSE file for details.
$$--GLUE--$$
.\crates\isopod\Cargo.toml
$$--GLUE--$$
[package]
name = "isopod"
version = "0.1.0"
edition = "2021"
license = "MIT"
description = "ISO 9660 library for creating, reading, and manipulating ISO filesystem images"
authors = ["Maxine DeAndrade"]
repository = "https://github.com/maxine-deandrade/isopod"
keywords = ["iso", "iso9660", "filesystem", "cd", "dvd"]
categories = ["filesystem"]
readme = "README.md"

[dependencies]
thiserror = "1.0"
chrono = "0.4"
log = "0.4"

[dev-dependencies]
tempfile = "3.3"
$$--GLUE--$$
.\crates\isopod\README.md
$$--GLUE--$$
# isopod

A Rust library for creating, reading, and manipulating ISO 9660 filesystem images.

## Overview

isopod implements the ISO 9660 standard (ECMA-119) for optical disc filesystems. It allows you to:

- Create new ISO 9660 images
- Read and extract files from existing ISO images
- Modify ISO image content
- Support multiple ISO 9660 extensions

## Usage Examples

### Creating a New ISO

```rust
use isopod::{Iso, IsoBuilder};
use std::path::Path;

fn main() -> isopod::Result<()> {
    // Create a new ISO with custom properties
    let mut iso = Iso::builder()
        .volume_id("MY_VOLUME")
        .publisher("Publisher Name")
        .preparer("Data Preparer")
        .application("My Application")
        .joliet(true)  // Enable Joliet extension
        .build()?;
    
    // Add directories
    iso.add_directory("docs")?;
    iso.add_directory("docs/images")?;
    
    // Add files from the filesystem
    iso.add_file("docs/readme.txt", Path::new("local/path/to/readme.txt"))?;
    iso.add_file("docs/images/logo.png", Path::new("local/path/to/logo.png"))?;
    
    // Add a file with content
    let content = b"Hello, world!";
    iso.add_file_with_content("hello.txt", content)?;
    
    // Save the ISO
    iso.save("output.iso")?;
    
    Ok(())
}
```

### Reading an ISO

```rust
use isopod::Iso;
use std::path::Path;

fn main() -> isopod::Result<()> {
    // Open an existing ISO
    let iso = Iso::open("input.iso")?;
    
    // Get volume information
    println!("Volume ID: {}", iso.volume_descriptor().volume_id());
    println!("Publisher: {}", iso.volume_descriptor().publisher_id());
    
    // Extract a file
    iso.extract_file("docs/readme.txt", Path::new("extracted_readme.txt"))?;
    
    // Get file content
    let content = iso.get_file_content("hello.txt")?;
    println!("Content: {}", String::from_utf8_lossy(&content));
    
    // Print file listing
    print_directory(iso.root_directory(), Path::new(""));
    
    Ok(())
}

fn print_directory(dir: &isopod::Directory, path: &Path) {
    // Print files
    for (name, _) in dir.files() {
        println!("File: {}", path.join(name).display());
    }
    
    // Print and traverse subdirectories
    for (name, subdir) in dir.directories() {
        println!("Directory: {}/", path.join(name).display());
        print_directory(subdir, &path.join(name));
    }
}
```

## Features

### ISO 9660 Extensions

isopod supports several extensions to the basic ISO 9660 standard:

#### Joliet

Adds support for:
- Long file names (up to 64 characters)
- Unicode characters
- Deeper directory hierarchies

Enable with:

```rust
Iso::builder().joliet(true).build()?;
```

#### Rock Ridge

Adds POSIX filesystem features:
- File permissions
- Symbolic links
- Deep directory hierarchies
- Long file names

Enable with:

```rust
Iso::builder().rock_ridge(true).build()?;
```

#### El Torito

Adds support for bootable CDs/DVDs.

Enable with:

```rust
Iso::builder().el_torito(true).build()?;
```

#### UDF Bridge

Universal Disk Format support for compatibility with modern systems.

Enable with:

```rust
Iso::builder().udf(true).build()?;
```

## API Documentation

For detailed API documentation, run:

```bash
cargo doc --open
```

## Standards Compliance

This library aims to implement the ISO 9660 standard (ECMA-119) correctly, with additional support for common extensions.

### Limitations

- Maximum file size: 4GB (32-bit size limit in ISO 9660)
- Default filename restrictions follow ISO 9660 Level 1:
  - Up to 8 characters for filename + 3 for extension
  - Uppercase letters, numbers, and underscore only
  - These restrictions are lifted when using extensions like Joliet or Rock Ridge

## Performance Considerations

- Creating ISOs with many small files can be slow due to the need to write each file's content to a separate sector
- For best performance when creating large ISOs, add files in sorted order
$$--GLUE--$$
.\crates\isopod\src\directory.rs
$$--GLUE--$$
use std::collections::HashMap;
use std::io::{Read, Seek, SeekFrom, Write};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::constants::SECTOR_SIZE;
use crate::file::File;
use crate::utils;
use crate::Error;
use crate::Result;

/// Directory entry flags
#[repr(u8)]
pub enum DirectoryEntryFlag {
  Hidden = 0x01,
  Directory = 0x02,
  AssociatedFile = 0x04,
  Record = 0x08,
  Protection = 0x10,
  MultiExtent = 0x80,
}

/// Represents a directory entry in the ISO 9660 filesystem
#[derive(Debug, Clone)]
pub struct DirectoryEntry {
  /// Entry name
  name: String,

  /// Entry flags
  flags: u8,

  /// Location of extent (sector)
  extent_location: u32,

  /// Size of extent (bytes)
  extent_size: u32,

  /// Recording date and time
  recording_time: SystemTime,
}

impl DirectoryEntry {
  /// Create a new file entry
  pub fn new_file(name: &str, extent_location: u32, extent_size: u32) -> Self {
    Self {
      name: name.to_string(),
      flags: 0,
      extent_location,
      extent_size,
      recording_time: SystemTime::now(),
    }
  }

  /// Create a new directory entry
  pub fn new_directory(name: &str, extent_location: u32, extent_size: u32) -> Self {
    Self {
      name: name.to_string(),
      flags: DirectoryEntryFlag::Directory as u8,
      extent_location,
      extent_size,
      recording_time: SystemTime::now(),
    }
  }

  /// Parse a directory entry from a buffer
  pub fn parse_from_buffer(buffer: &[u8]) -> Option<Self> {
    // Buffer needs to be at least 33 bytes to contain the minimum directory record
    if buffer.len() < 33 || buffer[0] == 0 {
      return None;
    }

    // Record length
    let record_length = buffer[0] as usize;
    if record_length < 33 || record_length > buffer.len() {
      return None;
    }

    // Extended attribute record length
    let _ext_attr_length = buffer[1];

    // Extent location
    let extent_location = utils::parse_u32_both(&buffer[2..10]);

    // Data length
    let extent_size = utils::parse_u32_both(&buffer[10..18]);

    // Recording date/time
    let recording_time = utils::parse_recording_date(&buffer[18..25]).unwrap_or(UNIX_EPOCH);

    // File flags
    let flags = buffer[25];

    // File unit size and interleave
    let _file_unit_size = buffer[26];
    let _interleave_gap = buffer[27];

    // Volume sequence number
    let _volume_sequence = utils::parse_u16_both(&buffer[28..32]);

    // File identifier length
    let file_id_length = buffer[32] as usize;

    if 33 + file_id_length > record_length {
      return None;
    }

    // File identifier
    let name = if (flags & (DirectoryEntryFlag::Directory as u8)) != 0 && file_id_length == 1 {
      match buffer[33] {
        0 => ".".to_string(),  // Current directory
        1 => "..".to_string(), // Parent directory
        _ => format!("UNKNOWN_{}", buffer[33]),
      }
    } else {
      let raw_name = &buffer[33..33 + file_id_length];
      // Detect if this is a file with a version suffix (;1)
      if raw_name.ends_with(b";1") {
        utils::parse_iso_string(&raw_name[0..raw_name.len() - 2])
      } else {
        utils::parse_iso_string(raw_name)
      }
    };

    Some(Self {
      name,
      flags,
      extent_location,
      extent_size,
      recording_time,
    })
  }

  /// Write the directory entry to a buffer
  pub fn write_to_buffer(&self, buffer: &mut [u8]) -> Result<()> {
    // Start with the base record length (33) + file ID length
    let file_id_bytes = self.iso_file_identifier();
    let file_id_length = file_id_bytes.len();
    let record_length = 33 + file_id_length;

    // Pad to even length if needed
    let padded_length = if record_length % 2 == 1 {
      record_length + 1
    } else {
      record_length
    };

    if buffer.len() < padded_length {
      return Err(Error::InvalidFormat(format!(
        "Buffer too small for directory entry: need {} bytes, got {}",
        padded_length,
        buffer.len()
      )));
    }

    // Clear the buffer
    buffer[0..padded_length].fill(0);

    // Record length
    buffer[0] = padded_length as u8;

    // Extended attribute record length
    buffer[1] = 0;

    // Extent location (both little and big endian)
    utils::write_u32_both(&mut buffer[2..10], self.extent_location);

    // Data length (both little and big endian)
    utils::write_u32_both(&mut buffer[10..18], self.extent_size);

    // Recording date/time
    utils::write_recording_date(&mut buffer[18..25], self.recording_time);

    // File flags
    buffer[25] = self.flags;

    // File unit size and interleave
    buffer[26] = 0; // File unit size
    buffer[27] = 0; // Interleave gap

    // Volume sequence number
    utils::write_u16_both(&mut buffer[28..32], 1);

    // File identifier length
    buffer[32] = file_id_length as u8;

    // File identifier
    buffer[33..33 + file_id_length].copy_from_slice(&file_id_bytes);

    Ok(())
  }

  /// Get the name
  pub fn name(&self) -> &str {
    &self.name
  }

  /// Get the flags
  pub fn flags(&self) -> u8 {
    self.flags
  }

  /// Set the flags
  pub fn set_flags(&mut self, flags: u8) {
    self.flags = flags;
  }

  /// Check if this is a directory
  pub fn is_directory(&self) -> bool {
    (self.flags & (DirectoryEntryFlag::Directory as u8)) != 0
  }

  /// Get the extent location
  pub fn extent_location(&self) -> u32 {
    self.extent_location
  }

  /// Set the extent location
  pub fn set_extent_location(&mut self, location: u32) {
    self.extent_location = location;
  }

  /// Get the extent size
  pub fn extent_size(&self) -> u32 {
    self.extent_size
  }

  /// Set the extent size
  pub fn set_extent_size(&mut self, size: u32) {
    self.extent_size = size;
  }

  /// Get the recording time
  pub fn recording_time(&self) -> SystemTime {
    self.recording_time
  }

  /// Set the recording time
  pub fn set_recording_time(&mut self, time: SystemTime) {
    self.recording_time = time;
  }

  /// Calculate the record size of this entry
  pub fn record_size(&self) -> usize {
    let file_id_length = self.iso_file_identifier().len();
    let record_length = 33 + file_id_length;

    // Pad to even length if needed
    if record_length % 2 == 1 {
      record_length + 1
    } else {
      record_length
    }
  }

  /// Get the ISO file identifier
  fn iso_file_identifier(&self) -> Vec<u8> {
    if self.is_directory() {
      if self.name == "." {
        return vec![0];
      } else if self.name == ".." {
        return vec![1];
      }
    }

    // Sanitize the name for ISO 9660 compliance (allow only A-Z, 0-9, _)
    let sanitized_name = self
      .name
      .chars()
      .map(|c| {
        if c.is_ascii_alphanumeric() || c == '_' || c == '.' {
          c.to_ascii_uppercase()
        } else {
          '_'
        }
      })
      .collect::<String>();

    // For files, append ";1" version
    if !self.is_directory() {
      let mut file_id = sanitized_name.as_bytes().to_vec();
      file_id.extend_from_slice(b";1");
      file_id
    } else {
      sanitized_name.as_bytes().to_vec()
    }
  }
}

/// Represents a directory in the ISO 9660 filesystem
#[derive(Debug, Clone)]
pub struct Directory {
  /// Directory name
  name: String,

  /// Subdirectories
  directories: HashMap<String, Directory>,

  /// Files
  files: HashMap<String, File>,

  /// Sector location
  sector_location: Option<u32>,

  /// Size in bytes
  size: Option<u32>,
}

impl Directory {
  /// Create a new directory
  pub fn new(name: &str) -> Self {
    Self {
      name: name.to_string(),
      directories: HashMap::new(),
      files: HashMap::new(),
      sector_location: None,
      size: None,
    }
  }

  /// Read a directory from an ISO
  pub fn read_from_iso<R: Read + Seek>(reader: &mut R, entry: &DirectoryEntry) -> Result<Self> {
    if !entry.is_directory() {
      return Err(Error::InvalidFormat("Entry is not a directory".into()));
    }

    let location = entry.extent_location();
    let size = entry.extent_size();

    if location == 0 || size == 0 {
      return Err(Error::InvalidFormat(format!(
        "Invalid directory location ({}) or size ({})",
        location, size
      )));
    }

    // Sanity check the size to prevent excessive memory allocation
    if size > 10 * 1024 * 1024 {
      // Limit to 10MB for a directory
      return Err(Error::SizeLimit(format!(
        "Directory size exceeds reasonable limit: {} bytes",
        size
      )));
    }

    let mut buffer = vec![0u8; size as usize];
    let position = location as u64 * SECTOR_SIZE as u64;

    // Attempt to seek and read
    match reader.seek(SeekFrom::Start(position)) {
      Ok(_) => {}
      Err(e) => {
        return Err(Error::Io(e));
      }
    }

    match reader.read_exact(&mut buffer) {
      Ok(_) => {}
      Err(e) => {
        return Err(Error::Io(e));
      }
    }

    let mut directory = Self::new(entry.name());
    directory.sector_location = Some(location);
    directory.size = Some(size);

    // Parse directory entries
    let mut offset = 0;
    while offset < buffer.len() {
      // Check for end of entries
      if buffer[offset] == 0 || offset + 1 >= buffer.len() {
        break;
      }

      // Get record length
      let record_length = buffer[offset] as usize;
      if record_length == 0 || offset + record_length > buffer.len() {
        // Invalid record length, skip to next sector
        offset = (offset + SECTOR_SIZE) & !(SECTOR_SIZE - 1);
        continue;
      }

      // Parse directory entry
      if let Some(entry) =
        DirectoryEntry::parse_from_buffer(&buffer[offset..offset + record_length])
      {
        // Skip . and .. entries
        if entry.name() != "." && entry.name() != ".." {
          if entry.is_directory() {
            // Recursively read subdirectory, but with safeguards against circular references
            if entry.extent_location() != location {
              // Avoid self-referential directories
              match Self::read_from_iso(reader, &entry) {
                Ok(subdir) => {
                  directory
                    .directories
                    .insert(entry.name().to_string(), subdir);
                }
                Err(e) => {
                  // Log error but continue with other entries
                  eprintln!("Error reading subdirectory '{}': {}", entry.name(), e);
                }
              }
            }
          } else {
            // Read file content with safeguards
            if entry.extent_location() > 0 && entry.extent_size() > 0 {
              // Sanity check file size
              if entry.extent_size() > 100 * 1024 * 1024 {
                // Limit to 100MB for a file
                eprintln!(
                  "Skipping file '{}': size too large ({})",
                  entry.name(),
                  entry.extent_size()
                );
              } else {
                let mut file_buffer = vec![0u8; entry.extent_size() as usize];
                if let Ok(_) = reader.seek(SeekFrom::Start(
                  entry.extent_location() as u64 * SECTOR_SIZE as u64,
                )) {
                  if let Ok(_) = reader.read_exact(&mut file_buffer) {
                    // Create file
                    let file = File::new(entry.name(), file_buffer);
                    directory.files.insert(entry.name().to_string(), file);
                  }
                }
              }
            }
          }
        }
      }

      offset += record_length;
    }

    Ok(directory)
  }

  /// Write the directory to an ISO
  pub fn write_to_iso<W: Write + Seek>(&self, writer: &mut W) -> Result<()> {
    // First, write all subdirectories and files to get their locations
    let mut updated_directories = HashMap::new();
    let mut updated_files = HashMap::new();

    // Start after the system area, volume descriptors, and path tables
    // This is just an example - in a real implementation this would be tracked
    let mut next_sector = 20;

    // Write subdirectories
    for (name, directory) in &self.directories {
      // Create a copy of the directory with updated sector information
      let mut updated_dir = directory.clone();
      updated_dir.sector_location = Some(next_sector);

      // Calculate how many sectors this directory will occupy
      let dir_size = updated_dir.calculate_size();
      let sectors_needed = (dir_size + SECTOR_SIZE as u32 - 1) / SECTOR_SIZE as u32;
      updated_dir.size = Some(dir_size);

      // Write the directory
      writer.seek(SeekFrom::Start(next_sector as u64 * SECTOR_SIZE as u64))?;
      updated_dir.write_directory_record(writer)?;

      // Update next sector
      next_sector += sectors_needed;

      // Store updated directory
      updated_directories.insert(name.clone(), updated_dir);
    }

    // Write files
    for (name, file) in &self.files {
      let file_content = file.content();
      let file_size = file_content.len() as u32;

      // Write file content
      writer.seek(SeekFrom::Start(next_sector as u64 * SECTOR_SIZE as u64))?;

      // Pad content to sector boundary
      let padding_needed = (SECTOR_SIZE - (file_content.len() % SECTOR_SIZE)) % SECTOR_SIZE;
      writer.write_all(file_content)?;
      if padding_needed > 0 {
        writer.write_all(&vec![0u8; padding_needed])?;
      }

      // Calculate sectors occupied by the file
      let sectors_needed = (file_size + SECTOR_SIZE as u32 - 1) / SECTOR_SIZE as u32;

      // Create updated file
      let mut updated_file = file.clone();
      updated_file.set_sector_location(next_sector);
      updated_file.set_size(file_size);

      // Update next sector
      next_sector += sectors_needed;

      // Store updated file
      updated_files.insert(name.clone(), updated_file);
    }

    // Now write this directory record
    if let Some(location) = self.sector_location {
      writer.seek(SeekFrom::Start(location as u64 * SECTOR_SIZE as u64))?;

      // Create directory record with . and .. entries
      let mut buffer = Vec::with_capacity(SECTOR_SIZE * 2); // Pre-allocate enough space

      // "." entry (current directory)
      let dot_entry = DirectoryEntry::new_directory(".", location, self.calculate_size());
      let entry_size = dot_entry.record_size();
      let mut entry_buffer = vec![0u8; entry_size + 16]; // Add extra padding for safety
      if let Err(e) = dot_entry.write_to_buffer(&mut entry_buffer[0..entry_size]) {
        return Err(Error::InvalidFormat(format!(
          "Failed to write '.' directory entry: {}",
          e
        )));
      }
      buffer.extend_from_slice(&entry_buffer[0..entry_size]);

      // ".." entry (parent directory - would be set properly in a real implementation)
      let parent_location = location; // In a real implementation, this would be the parent's location
      let dotdot_entry = DirectoryEntry::new_directory("..", parent_location, 0);
      let entry_size = dotdot_entry.record_size();
      let mut entry_buffer = vec![0u8; entry_size + 16]; // Add extra padding for safety
      if let Err(e) = dotdot_entry.write_to_buffer(&mut entry_buffer[0..entry_size]) {
        return Err(Error::InvalidFormat(format!(
          "Failed to write '..' directory entry: {}",
          e
        )));
      }
      buffer.extend_from_slice(&entry_buffer[0..entry_size]);

      // Add entries for subdirectories
      for directory in updated_directories.values() {
        let dir_location = match directory.sector_location {
          Some(loc) => loc,
          None => {
            return Err(Error::InvalidFormat(format!(
              "Directory '{}' has no sector location",
              directory.name()
            )))
          }
        };

        let dir_size = match directory.size {
          Some(size) => size,
          None => {
            return Err(Error::InvalidFormat(format!(
              "Directory '{}' has no size",
              directory.name()
            )))
          }
        };

        let dir_entry = DirectoryEntry::new_directory(directory.name(), dir_location, dir_size);
        let entry_size = dir_entry.record_size();
        let mut entry_buffer = vec![0u8; entry_size + 16]; // Add extra padding for safety
        if let Err(e) = dir_entry.write_to_buffer(&mut entry_buffer[0..entry_size]) {
          return Err(Error::InvalidFormat(format!(
            "Failed to write directory entry for '{}': {}",
            directory.name(),
            e
          )));
        }
        buffer.extend_from_slice(&entry_buffer[0..entry_size]);
      }

      // Add entries for files
      for file in updated_files.values() {
        let file_location = match file.sector_location() {
          Some(loc) => loc,
          None => {
            return Err(Error::InvalidFormat(format!(
              "File '{}' has no sector location",
              file.name()
            )))
          }
        };

        let file_size = match file.size() {
          Some(size) => size,
          None => {
            return Err(Error::InvalidFormat(format!(
              "File '{}' has no size",
              file.name()
            )))
          }
        };

        let file_entry = DirectoryEntry::new_file(file.name(), file_location, file_size);
        let entry_size = file_entry.record_size();
        let mut entry_buffer = vec![0u8; entry_size + 16]; // Add extra padding for safety
        if let Err(e) = file_entry.write_to_buffer(&mut entry_buffer[0..entry_size]) {
          return Err(Error::InvalidFormat(format!(
            "Failed to write file entry for '{}': {}",
            file.name(),
            e
          )));
        }
        buffer.extend_from_slice(&entry_buffer[0..entry_size]);
      }

      // Pad to sector size
      let padding_needed = SECTOR_SIZE - (buffer.len() % SECTOR_SIZE);
      if padding_needed < SECTOR_SIZE {
        buffer.extend(vec![0u8; padding_needed]);
      }

      // Write directory record
      writer.write_all(&buffer)?;
    }

    Ok(())
  }

  /// Calculate the size of this directory record
  fn calculate_size(&self) -> u32 {
    // Size of "." and ".." entries
    let mut size = self.create_dot_entry().record_size() + self.create_dotdot_entry().record_size();

    // Size of subdirectory entries
    for dir in self.directories.values() {
      let entry = DirectoryEntry::new_directory(dir.name(), 0, 0);
      size += entry.record_size();
    }

    // Size of file entries
    for file in self.files.values() {
      let entry = DirectoryEntry::new_file(file.name(), 0, 0);
      size += entry.record_size();
    }

    size as u32
  }

  /// Create a "." directory entry
  fn create_dot_entry(&self) -> DirectoryEntry {
    let location = self.sector_location.unwrap_or(0);
    let size = self.size.unwrap_or(0);
    DirectoryEntry::new_directory(".", location, size)
  }

  /// Create a ".." directory entry
  fn create_dotdot_entry(&self) -> DirectoryEntry {
    // In a real implementation, this would use the parent's location
    let location = self.sector_location.unwrap_or(0);
    DirectoryEntry::new_directory("..", location, 0)
  }

  /// Write the directory record to a writer
  fn write_directory_record<W: Write>(&self, writer: &mut W) -> Result<()> {
    // Create directory record with . and .. entries
    let mut buffer = Vec::new();

    // "." entry (current directory)
    let dot_entry = self.create_dot_entry();
    let mut entry_buffer = vec![0u8; dot_entry.record_size()];
    dot_entry.write_to_buffer(&mut entry_buffer)?;
    buffer.extend_from_slice(&entry_buffer);

    // ".." entry (parent directory)
    let dotdot_entry = self.create_dotdot_entry();
    let mut entry_buffer = vec![0u8; dotdot_entry.record_size()];
    dotdot_entry.write_to_buffer(&mut entry_buffer)?;
    buffer.extend_from_slice(&entry_buffer);

    // Add entries for subdirectories
    for dir in self.directories.values() {
      if let (Some(location), Some(size)) = (dir.sector_location, dir.size) {
        let dir_entry = DirectoryEntry::new_directory(dir.name(), location, size);
        let mut entry_buffer = vec![0u8; dir_entry.record_size()];
        dir_entry.write_to_buffer(&mut entry_buffer)?;
        buffer.extend_from_slice(&entry_buffer);
      }
    }

    // Add entries for files
    for file in self.files.values() {
      if let (Some(location), Some(size)) = (file.sector_location(), file.size()) {
        let file_entry = DirectoryEntry::new_file(file.name(), location, size);
        let mut entry_buffer = vec![0u8; file_entry.record_size()];
        file_entry.write_to_buffer(&mut entry_buffer)?;
        buffer.extend_from_slice(&entry_buffer);
      }
    }

    // Pad to sector size
    let padding_needed = SECTOR_SIZE - (buffer.len() % SECTOR_SIZE);
    if padding_needed < SECTOR_SIZE {
      buffer.extend(vec![0u8; padding_needed]);
    }

    // Write directory record
    writer.write_all(&buffer)?;

    Ok(())
  }

  /// Get the directory name
  pub fn name(&self) -> &str {
    &self.name
  }

  /// Set the directory name
  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  /// Get a reference to the subdirectories
  pub fn directories(&self) -> &HashMap<String, Directory> {
    &self.directories
  }

  /// Get a mutable reference to the subdirectories
  pub fn directories_mut(&mut self) -> &mut HashMap<String, Directory> {
    &mut self.directories
  }

  /// Get a reference to the files
  pub fn files(&self) -> &HashMap<String, File> {
    &self.files
  }

  /// Get a mutable reference to the files
  pub fn files_mut(&mut self) -> &mut HashMap<String, File> {
    &mut self.files
  }

  /// Find a subdirectory by name
  pub fn find_directory(&self, name: &str) -> Option<&Directory> {
    self.directories.get(name)
  }

  /// Find a subdirectory by name and get a mutable reference
  pub fn find_directory_mut(&mut self, name: &str) -> Option<&mut Directory> {
    self.directories.get_mut(name)
  }

  /// Find a file by name
  pub fn find_file(&self, name: &str) -> Option<&File> {
    self.files.get(name)
  }

  /// Find a file by name and get a mutable reference
  pub fn find_file_mut(&mut self, name: &str) -> Option<&mut File> {
    self.files.get_mut(name)
  }

  /// Add a subdirectory
  pub fn add_directory(&mut self, name: String) -> Result<()> {
    if self.directories.contains_key(&name) {
      return Err(Error::PathError(format!(
        "Directory already exists: {}",
        name
      )));
    }

    let directory = Directory::new(&name);
    self.directories.insert(name, directory);

    Ok(())
  }

  /// Add a file
  pub fn add_file(&mut self, name: String, content: &[u8]) -> Result<()> {
    if self.files.contains_key(&name) {
      return Err(Error::PathError(format!("File already exists: {}", name)));
    }

    let file = File::new(&name, content.to_vec());
    self.files.insert(name, file);

    Ok(())
  }

  /// Remove a subdirectory
  pub fn remove_directory(&mut self, name: &str) -> Option<Directory> {
    self.directories.remove(name)
  }

  /// Remove a file
  pub fn remove_file(&mut self, name: &str) -> Option<File> {
    self.files.remove(name)
  }

  /// Convert this directory to a directory entry
  pub fn to_entry(&self) -> DirectoryEntry {
    let location = self.sector_location.unwrap_or(0);
    let size = self.size.unwrap_or_else(|| self.calculate_size());

    DirectoryEntry::new_directory(&self.name, location, size)
  }

  /// Set the sector location
  pub fn set_sector_location(&mut self, location: u32) {
    self.sector_location = Some(location);
  }

  /// Get the sector location
  pub fn sector_location(&self) -> Option<u32> {
    self.sector_location
  }

  /// Set the size
  pub fn set_size(&mut self, size: u32) {
    self.size = Some(size);
  }

  /// Get the size
  pub fn size(&self) -> Option<u32> {
    self.size
  }
}

$$--GLUE--$$
.\crates\isopod\src\error.rs
$$--GLUE--$$
use std::fmt;
use std::io;

/// Error type for ISO operations
#[derive(Debug)]
pub enum Error {
    /// I/O error from underlying operations
    Io(io::Error),
    
    /// Invalid ISO format
    InvalidFormat(String),
    
    /// Validation error during ISO creation
    ValidationError(String),
    
    /// Path error (too long, invalid characters, etc.)
    PathError(String),
    
    /// Size limit exceeded
    SizeLimit(String),
    
    /// UDF specific error
    UdfError(String),
    
    /// Joliet extension error
    JolietError(String),
    
    /// Rock Ridge extension error
    RockRidgeError(String),
    
    /// El Torito boot extension error
    ElToritoError(String),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::Io(err) => write!(f, "I/O error: {}", err),
            Error::InvalidFormat(msg) => write!(f, "Invalid ISO format: {}", msg),
            Error::ValidationError(msg) => write!(f, "Validation error: {}", msg),
            Error::PathError(msg) => write!(f, "Path error: {}", msg),
            Error::SizeLimit(msg) => write!(f, "Size limit exceeded: {}", msg),
            Error::UdfError(msg) => write!(f, "UDF error: {}", msg),
            Error::JolietError(msg) => write!(f, "Joliet error: {}", msg),
            Error::RockRidgeError(msg) => write!(f, "Rock Ridge error: {}", msg),
            Error::ElToritoError(msg) => write!(f, "El Torito error: {}", msg),
        }
    }
}

impl std::error::Error for Error {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Error::Io(err) => Some(err),
            _ => None,
        }
    }
}

impl From<io::Error> for Error {
    fn from(err: io::Error) -> Self {
        Error::Io(err)
    }
}
$$--GLUE--$$
.\crates\isopod\src\file.rs
$$--GLUE--$$
use std::time::SystemTime;

/// Represents a file in the ISO 9660 filesystem
#[derive(Debug, Clone)]
pub struct File {
    /// File name
    name: String,
    
    /// File content
    content: Vec<u8>,
    
    /// Sector location in the ISO
    sector_location: Option<u32>,
    
    /// File size in bytes
    size: Option<u32>,
    
    /// Creation time
    creation_time: SystemTime,
    
    /// Modification time
    modification_time: SystemTime,
}

impl File {
    /// Create a new file
    pub fn new(name: &str, content: Vec<u8>) -> Self {
        let now = SystemTime::now();
        
        Self {
            name: name.to_string(),
            content,
            sector_location: None,
            size: None,
            creation_time: now,
            modification_time: now,
        }
    }
    
    /// Get the file name
    pub fn name(&self) -> &str {
        &self.name
    }
    
    /// Set the file name
    pub fn set_name(&mut self, name: String) {
        self.name = name;
    }
    
    /// Get the file content
    pub fn content(&self) -> &[u8] {
        &self.content
    }
    
    /// Get a mutable reference to the file content
    pub fn content_mut(&mut self) -> &mut Vec<u8> {
        &mut self.content
    }
    
    /// Set the file content
    pub fn set_content(&mut self, content: Vec<u8>) {
        let size = content.len() as u32;
        self.content = content;
        self.size = Some(size);
    }
    
    /// Get the sector location
    pub fn sector_location(&self) -> Option<u32> {
        self.sector_location
    }
    
    /// Set the sector location
    pub fn set_sector_location(&mut self, location: u32) {
        self.sector_location = Some(location);
    }
    
    /// Get the file size
    pub fn size(&self) -> Option<u32> {
        self.size.or_else(|| Some(self.content.len() as u32))
    }
    
    /// Set the file size
    pub fn set_size(&mut self, size: u32) {
        self.size = Some(size);
    }
    
    /// Get the creation time
    pub fn creation_time(&self) -> SystemTime {
        self.creation_time
    }
    
    /// Set the creation time
    pub fn set_creation_time(&mut self, time: SystemTime) {
        self.creation_time = time;
    }
    
    /// Get the modification time
    pub fn modification_time(&self) -> SystemTime {
        self.modification_time
    }
    
    /// Set the modification time
    pub fn set_modification_time(&mut self, time: SystemTime) {
        self.modification_time = time;
    }
}
$$--GLUE--$$
.\crates\isopod\src\iso.rs
$$--GLUE--$$
use std::fs::File;
use std::io::{Read, Write, Seek, SeekFrom};
use std::path::{Path, PathBuf};
use log::debug;

use crate::constants::SECTOR_SIZE;
use crate::directory::{Directory, DirectoryEntry};
use crate::volume::{PrimaryVolumeDescriptor, VolumeDescriptor};
use crate::{Result, Error};

/// Represents an ISO 9660 image
pub struct Iso {
    /// The primary volume descriptor for this ISO
    volume_descriptor: PrimaryVolumeDescriptor,
    
    /// Root directory of the ISO filesystem
    root_directory: Directory,
    
    /// Path to the backing file if loaded from or saved to disk
    path: Option<PathBuf>,
    
    /// Whether this ISO has been modified since loading
    modified: bool,
    
    /// Extensions supported by this ISO
    extensions: IsoExtensions,
}

/// Supported ISO 9660 extensions
#[derive(Debug, Default, Clone)]
pub struct IsoExtensions {
    /// Joliet extension for long file names and Unicode support
    pub joliet: bool,
    
    /// Rock Ridge extension for POSIX filesystem features
    pub rock_ridge: bool,
    
    /// El Torito extension for bootable CDs
    pub el_torito: bool,
    
    /// UDF (Universal Disk Format) bridge
    pub udf: bool,
}

impl Iso {
    /// Create a new builder for an ISO
    pub fn builder() -> IsoBuilder {
        IsoBuilder::new()
    }
    
    /// Open an existing ISO file
    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self> {
        let mut file = File::open(path.as_ref())?;
        let mut iso = Self::read_from(&mut file)?;
        iso.path = Some(path.as_ref().to_path_buf());
        Ok(iso)
    }
    
    /// Read an ISO from any reader
    pub fn read_from<R: Read + Seek>(reader: &mut R) -> Result<Self> {
        // Read the first 16 sectors to find volume descriptors
        let sector_count = 16;
        let buffer_size = SECTOR_SIZE * sector_count;
        let mut buffer = vec![0u8; buffer_size];
        
        // Seek to the beginning of the file
        reader.seek(SeekFrom::Start(0))?;
        
        // Try to read the full buffer, but handle if file is smaller
        match reader.read_exact(&mut buffer) {
            Ok(_) => {}
            Err(e) => {
                if e.kind() != std::io::ErrorKind::UnexpectedEof {
                    return Err(Error::Io(e));
                }
                
                // If we got an unexpected EOF, continue with what we read
                debug!("Warning: ISO appears to be smaller than expected. Continuing with partial data.");
            }
        }
        
        // Find and parse the primary volume descriptor
        let volume_descriptor = PrimaryVolumeDescriptor::parse_from_buffer(&buffer)
            .ok_or_else(|| Error::InvalidFormat("Failed to find primary volume descriptor".into()))?;
            
        // Parse root directory
        let root_entry = volume_descriptor.root_directory_entry().clone();
        
        // Validate root entry
        if root_entry.extent_location() == 0 || root_entry.extent_size() == 0 {
            return Err(Error::InvalidFormat("Invalid root directory entry".into()));
        }
        
        // Read the root directory
        let root_directory = match Directory::read_from_iso(reader, &root_entry) {
            Ok(dir) => dir,
            Err(e) => {
                return Err(Error::InvalidFormat(format!("Failed to read root directory: {}", e)));
            }
        };
        
        // Detect extensions
        let extensions = Self::detect_extensions(reader, &buffer)?;
        
        Ok(Self {
            volume_descriptor,
            root_directory,
            path: None,
            modified: false,
            extensions,
        })
    }
    
    /// Save the ISO to a file
    pub fn save<P: AsRef<Path>>(&mut self, path: P) -> Result<()> {
        let mut file = File::create(path.as_ref())?;
        self.write_to(&mut file)?;
        self.path = Some(path.as_ref().to_path_buf());
        self.modified = false;
        Ok(())
    }
    
    /// Write the ISO to any writer
    pub fn write_to<W: Write + Seek>(&self, writer: &mut W) -> Result<()> {
        // First 16 sectors are reserved for system area
        writer.seek(SeekFrom::Start(0))?;
        writer.write_all(&vec![0u8; SECTOR_SIZE * 16])?;
        
        // Write primary volume descriptor
        self.volume_descriptor.write_to(writer)?;
        
        // Write volume descriptor set terminator
        self.write_volume_descriptor_set_terminator(writer)?;
        
        // Write directory and file data
        self.root_directory.write_to_iso(writer)?;
        
        // Finalize the ISO
        writer.flush()?;
        
        Ok(())
    }
    
    /// Add a file to the ISO
    pub fn add_file<P: AsRef<Path>, S: AsRef<Path>>(&mut self, iso_path: P, source_path: S) -> Result<()> {
        // Load the file content
        let mut file = File::open(source_path.as_ref())?;
        let mut content = Vec::new();
        file.read_to_end(&mut content)?;
        
        // Add to the ISO
        self.add_file_with_content(iso_path, &content)?;
        
        self.modified = true;
        Ok(())
    }
    
    /// Add a file with the provided content
    pub fn add_file_with_content<P: AsRef<Path>>(&mut self, iso_path: P, content: &[u8]) -> Result<()> {
        let path = iso_path.as_ref();
        
        // Validate the path
        self.validate_path(path)?;
        
        // Get parent directory path
        let parent_path = path.parent().unwrap_or_else(|| Path::new(""));
        
        // Get or create parent directory
        let parent_dir = self.get_or_create_directory(parent_path)?;
        
        // Create file entry
        let filename = path.file_name()
            .ok_or_else(|| Error::PathError("Invalid filename".into()))?
            .to_string_lossy()
            .into_owned();
            
        // Add file to parent directory
        parent_dir.add_file(filename, content)?;
        
        self.modified = true;
        Ok(())
    }
    
    /// Add a directory to the ISO
    pub fn add_directory<P: AsRef<Path>>(&mut self, path: P) -> Result<()> {
        let path = path.as_ref();
        
        // Validate the path
        self.validate_path(path)?;
        
        // Get or create the directory
        self.get_or_create_directory(path)?;
        
        self.modified = true;
        Ok(())
    }
    
    /// Extract a file from the ISO
    pub fn extract_file<P: AsRef<Path>, D: AsRef<Path>>(&self, iso_path: P, dest_path: D) -> Result<()> {
        let file_content = self.get_file_content(iso_path)?;
        
        // Write to destination
        let mut file = File::create(dest_path.as_ref())?;
        file.write_all(&file_content)?;
        
        Ok(())
    }
    
    /// Get a file's content from the ISO
    pub fn get_file_content<P: AsRef<Path>>(&self, path: P) -> Result<Vec<u8>> {
        let path = path.as_ref();
        
        // Navigate to file location
        let parent_path = path.parent().unwrap_or_else(|| Path::new(""));
        let filename = path.file_name()
            .ok_or_else(|| Error::PathError("Invalid filename".into()))?
            .to_string_lossy();
            
        let directory = self.find_directory(parent_path)?;
        let file_entry = directory.find_file(&filename)
            .ok_or_else(|| Error::PathError(format!("File not found: {}", path.display())))?;
            
        Ok(file_entry.content().to_vec())
    }
    
    /// Get the root directory
    pub fn root_directory(&self) -> &Directory {
        &self.root_directory
    }
    
    /// Get a mutable reference to the root directory
    pub fn root_directory_mut(&mut self) -> &mut Directory {
        self.modified = true;
        &mut self.root_directory
    }
    
    /// Get the volume descriptor
    pub fn volume_descriptor(&self) -> &PrimaryVolumeDescriptor {
        &self.volume_descriptor
    }
    
    /// Get a mutable reference to the volume descriptor
    pub fn volume_descriptor_mut(&mut self) -> &mut PrimaryVolumeDescriptor {
        self.modified = true;
        &mut self.volume_descriptor
    }
    
    /// Check if the ISO has been modified
    pub fn is_modified(&self) -> bool {
        self.modified
    }
    
    /// Get the ISO extensions
    pub fn extensions(&self) -> &IsoExtensions {
        &self.extensions
    }
    
    // Private helper methods
    
    /// Validate a path for ISO 9660 compatibility
    fn validate_path(&self, path: &Path) -> Result<()> {
        // Check path depth
        if path.components().count() > crate::constants::MAX_PATH_DEPTH {
            return Err(Error::PathError(format!(
                "Path depth exceeds maximum of {}: {}",
                crate::constants::MAX_PATH_DEPTH,
                path.display()
            )));
        }
        
        // Skip validation for Joliet/Rock Ridge if enabled
        if self.extensions.joliet || self.extensions.rock_ridge {
            return Ok(());
        }
        
        // For each component, validate the filename
        for component in path.components() {
            if let std::path::Component::Normal(name) = component {
                let filename = name.to_string_lossy();
                
                // Check for ISO 9660 Level 1 compliance
                if let Some((name, ext)) = filename.split_once('.') {
                    if name.len() > crate::constants::MAX_FILENAME_LENGTH_LEVEL_1 {
                        return Err(Error::PathError(format!(
                            "Filename '{}' exceeds maximum length of {}",
                            name,
                            crate::constants::MAX_FILENAME_LENGTH_LEVEL_1
                        )));
                    }
                    
                    if ext.len() > crate::constants::MAX_EXTENSION_LENGTH_LEVEL_1 {
                        return Err(Error::PathError(format!(
                            "Extension '{}' exceeds maximum length of {}",
                            ext,
                            crate::constants::MAX_EXTENSION_LENGTH_LEVEL_1
                        )));
                    }
                } else if filename.len() > crate::constants::MAX_FILENAME_LENGTH_LEVEL_1 {
                    return Err(Error::PathError(format!(
                        "Filename '{}' exceeds maximum length of {}",
                        filename,
                        crate::constants::MAX_FILENAME_LENGTH_LEVEL_1
                    )));
                }
                
                // Check for valid characters
                if !filename.chars().all(|c| c.is_ascii_alphanumeric() || c == '_' || c == '.') {
                    return Err(Error::PathError(format!(
                        "Invalid filename"
                    )));
                }
            }
        }
        
        Ok(())
    }
    
    /// Find a directory by path
    fn find_directory(&self, path: &Path) -> Result<&Directory> {
        if path.as_os_str().is_empty() {
            return Ok(&self.root_directory);
        }
        
        let mut current_dir = &self.root_directory;
        
        for component in path.components() {
            if let std::path::Component::Normal(name) = component {
                let dir_name = name.to_string_lossy();
                current_dir = current_dir.find_directory(&dir_name)
                    .ok_or_else(|| Error::PathError(format!("Directory not found: {}", dir_name)))?;
            }
        }
        
        Ok(current_dir)
    }
    
    /// Get or create a directory by path
    fn get_or_create_directory(&mut self, path: &Path) -> Result<&mut Directory> {
        if path.as_os_str().is_empty() {
            return Ok(&mut self.root_directory);
        }
        
        let mut current_dir = &mut self.root_directory;
        
        for component in path.components() {
            if let std::path::Component::Normal(name) = component {
                let dir_name = name.to_string_lossy().into_owned();
                
                // Check if directory exists
                if current_dir.find_directory(&dir_name).is_none() {
                    // Create if it doesn't
                    current_dir.add_directory(dir_name.clone())?;
                }
                
                // Now it definitely exists, get a mutable reference to it
                current_dir = current_dir.find_directory_mut(&dir_name)
                    .ok_or_else(|| Error::PathError(format!("Failed to create directory: {}", dir_name)))?;
            }
        }
        
        Ok(current_dir)
    }
    
    /// Write volume descriptor set terminator
    fn write_volume_descriptor_set_terminator<W: Write + Seek>(&self, writer: &mut W) -> Result<()> {
        let sector_position = SECTOR_SIZE as u64 * (16 + 1); // After primary volume descriptor
        writer.seek(SeekFrom::Start(sector_position))?;
        
        let mut terminator = [0u8; SECTOR_SIZE];
        
        // Type code
        terminator[0] = crate::constants::volume_type::VOLUME_DESCRIPTOR_SET_TERMINATOR;
        
        // Standard identifier
        terminator[1..6].copy_from_slice(crate::constants::ISO_STANDARD_ID);
        
        // Version
        terminator[6] = 1;
        
        writer.write_all(&terminator)?;
        
        Ok(())
    }
    
    /// Detect ISO extensions
    fn detect_extensions<R: Read + Seek>(reader: &mut R, buffer: &[u8]) -> Result<IsoExtensions> {
        let mut extensions = IsoExtensions::default();
        
        // Scan for Joliet Supplementary Volume Descriptor
        for sector in 0..16 {
            let offset = sector * SECTOR_SIZE;
            if offset + 7 <= buffer.len() {
                if buffer[offset] == crate::constants::volume_type::SUPPLEMENTARY_VOLUME_DESCRIPTOR 
                   && &buffer[offset+1..offset+6] == crate::constants::ISO_STANDARD_ID {
                    // Check escape sequences for Joliet
                    if offset + 88 <= buffer.len() {
                        let escape_seq = &buffer[offset+88..offset+88+3];
                        if escape_seq == b"%/E" || escape_seq == b"%/C" || escape_seq == b"%/G" {
                            extensions.joliet = true;
                        }
                    }
                }
            }
        }
        
        // TODO: Implement detection for Rock Ridge, El Torito, and UDF
        
        Ok(extensions)
    }
}

/// Builder for creating ISO images
pub struct IsoBuilder {
    volume_id: String,
    publisher: String,
    preparer: String,
    application: String,
    extensions: IsoExtensions,
}

impl IsoBuilder {
    /// Create a new ISO builder
    pub fn new() -> Self {
        Self {
            volume_id: "ISO_VOLUME".to_string(),
            publisher: "".to_string(),
            preparer: "isopod".to_string(),
            application: format!("isopod {}", crate::VERSION),
            extensions: IsoExtensions::default(),
        }
    }
    
    /// Set the volume ID
    pub fn volume_id<S: Into<String>>(mut self, volume_id: S) -> Self {
        self.volume_id = volume_id.into();
        self
    }
    
    /// Set the publisher
    pub fn publisher<S: Into<String>>(mut self, publisher: S) -> Self {
        self.publisher = publisher.into();
        self
    }
    
    /// Set the data preparer
    pub fn preparer<S: Into<String>>(mut self, preparer: S) -> Self {
        self.preparer = preparer.into();
        self
    }
    
    /// Set the application
    pub fn application<S: Into<String>>(mut self, application: S) -> Self {
        self.application = application.into();
        self
    }
    
    /// Enable Joliet extension
    pub fn joliet(mut self, enable: bool) -> Self {
        self.extensions.joliet = enable;
        self
    }
    
    /// Enable Rock Ridge extension
    pub fn rock_ridge(mut self, enable: bool) -> Self {
        self.extensions.rock_ridge = enable;
        self
    }
    
    /// Enable El Torito extension
    pub fn el_torito(mut self, enable: bool) -> Self {
        self.extensions.el_torito = enable;
        self
    }
    
    /// Enable UDF bridge
    pub fn udf(mut self, enable: bool) -> Self {
        self.extensions.udf = enable;
        self
    }
    
    /// Build the ISO image
    pub fn build(self) -> Result<Iso> {
        // Create root directory
        let root_directory = Directory::new("ROOT");
        
        // Create primary volume descriptor
        let volume_descriptor = PrimaryVolumeDescriptor::new(
            &self.volume_id,
            &self.publisher,
            &self.preparer,
            &self.application,
            &root_directory,
        );
        
        Ok(Iso {
            volume_descriptor,
            root_directory,
            path: None,
            modified: true,
            extensions: self.extensions,
        })
    }
}

impl Default for IsoBuilder {
    fn default() -> Self {
        Self::new()
    }
}
$$--GLUE--$$
.\crates\isopod\src\lib.rs
$$--GLUE--$$
// ISO 9660 Library implementation
//
// This library provides functionality for creating, reading, and manipulating
// ISO 9660 filesystem images.

mod error;
mod iso;
mod volume;
mod directory;
mod file;
mod utils;

pub use error::Error;
pub use iso::{Iso, IsoBuilder};
pub use volume::{VolumeDescriptor, PrimaryVolumeDescriptor};
pub use directory::{Directory, DirectoryEntry};
pub use file::File;

/// Result type for operations that may return an Error
pub type Result<T> = std::result::Result<T, Error>;

/// Library version
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

/// ISO 9660 standard constants
pub mod constants {
    /// Standard identifier for ISO 9660
    pub const ISO_STANDARD_ID: &[u8; 5] = b"CD001";
    
    /// Volume descriptor types
    pub mod volume_type {
        pub const BOOT_RECORD: u8 = 0;
        pub const PRIMARY_VOLUME_DESCRIPTOR: u8 = 1;
        pub const SUPPLEMENTARY_VOLUME_DESCRIPTOR: u8 = 2;
        pub const VOLUME_PARTITION_DESCRIPTOR: u8 = 3;
        pub const VOLUME_DESCRIPTOR_SET_TERMINATOR: u8 = 255;
    }
    
    /// Sector size (2048 bytes)
    pub const SECTOR_SIZE: usize = 2048;
    
    /// Maximum filename length in ISO 9660 Level 1
    pub const MAX_FILENAME_LENGTH_LEVEL_1: usize = 8;
    
    /// Maximum extension length in ISO 9660 Level 1
    pub const MAX_EXTENSION_LENGTH_LEVEL_1: usize = 3;
    
    /// Maximum path depth in ISO 9660
    pub const MAX_PATH_DEPTH: usize = 8;
}
$$--GLUE--$$
.\crates\isopod\src\utils.rs
$$--GLUE--$$
use std::time::{SystemTime, Duration, UNIX_EPOCH};

/// Parse a string from an ISO 9660 buffer
pub fn parse_iso_string(buffer: &[u8]) -> String {
    let mut end = buffer.len();
    
    // Find the end of the string (null terminator or space padding)
    for i in 0..buffer.len() {
        if buffer[i] == 0 || buffer[i] == b' ' {
            end = i;
            break;
        }
    }
    
    // Convert to string, replacing invalid UTF-8 with replacement character
    String::from_utf8_lossy(&buffer[0..end]).into_owned()
}

/// Write a string to an ISO 9660 buffer, padded with spaces
pub fn write_iso_string(buffer: &mut [u8], s: &str) {
    let bytes = s.as_bytes();
    let len = bytes.len().min(buffer.len());
    
    // Clear buffer with spaces
    buffer.fill(b' ');
    
    // Copy string
    buffer[0..len].copy_from_slice(&bytes[0..len]);
}

/// Parse a u16 stored in both little and big endian
pub fn parse_u16_both(buffer: &[u8]) -> u16 {
    if buffer.len() < 4 {
        return 0;
    }
    
    // Use little endian value
    u16::from_le_bytes([buffer[0], buffer[1]])
}

/// Write a u16 in both little and big endian format
pub fn write_u16_both(buffer: &mut [u8], value: u16) {
    if buffer.len() < 4 {
        return;
    }
    
    // Little endian
    buffer[0..2].copy_from_slice(&value.to_le_bytes());
    
    // Big endian
    buffer[2..4].copy_from_slice(&value.to_be_bytes());
}

/// Parse a u32 stored in both little and big endian
pub fn parse_u32_both(buffer: &[u8]) -> u32 {
    if buffer.len() < 8 {
        return 0;
    }
    
    // Use little endian value
    u32::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]])
}

/// Write a u32 in both little and big endian format
pub fn write_u32_both(buffer: &mut [u8], value: u32) {
    if buffer.len() < 8 {
        return;
    }
    
    // Little endian
    buffer[0..4].copy_from_slice(&value.to_le_bytes());
    
    // Big endian
    buffer[4..8].copy_from_slice(&value.to_be_bytes());
}

/// Parse ISO 9660 date format (7 bytes)
///
/// Format: year (since 1900), month, day, hour, minute, second, timezone offset (in 15-minute intervals from GMT)
pub fn parse_recording_date(buffer: &[u8]) -> Option<SystemTime> {
    if buffer.len() < 7 {
        return None;
    }
    
    let year = 1900 + buffer[0] as u32;
    let month = buffer[1] as u32;
    let day = buffer[2] as u32;
    let hour = buffer[3] as u32;
    let minute = buffer[4] as u32;
    let second = buffer[5] as u32;
    let _tz_offset = buffer[6] as i8; // Timezone offset in 15-minute intervals
    
    // Convert to Unix timestamp
    // This is a simplified implementation
    let days_since_epoch = (year - 1970) * 365 + (year - 1969) / 4 + days_in_month(year, month) + day - 1;
    let seconds_since_epoch = days_since_epoch * 86400 + hour * 3600 + minute * 60 + second;
    
    SystemTime::UNIX_EPOCH.checked_add(Duration::from_secs(seconds_since_epoch as u64))
}

/// Write recording date in ISO 9660 format
pub fn write_recording_date(buffer: &mut [u8], time: SystemTime) {
    if buffer.len() < 7 {
        return;
    }
    
    // Convert to calendar date/time
    let duration = time.duration_since(UNIX_EPOCH).unwrap_or_else(|_| Duration::from_secs(0));
    let secs = duration.as_secs();
    
    let second = (secs % 60) as u8;
    let minute = ((secs / 60) % 60) as u8;
    let hour = ((secs / 3600) % 24) as u8;
    
    // Calculate days since epoch (Jan 1, 1970)
    let days = (secs / 86400) as u32;
    
    // Simple estimate of year/month/day
    // This is a simplified calculation
    let year = 1970 + days / 365;
    let remaining_days = days % 365;
    
    // Simple month calculation (not accurate for leap years)
    let (month, day) = estimate_month_day(remaining_days, is_leap_year(year));
    
    buffer[0] = (year - 1900) as u8;
    buffer[1] = month as u8;
    buffer[2] = day as u8;
    buffer[3] = hour;
    buffer[4] = minute;
    buffer[5] = second;
    buffer[6] = 0; // GMT
}

/// Parse ISO 9660 extended date format (17 bytes)
///
/// Format: "YYYYMMDDHHMMSSFF"
pub fn parse_iso_date(buffer: &[u8]) -> Option<SystemTime> {
    if buffer.len() < 16 {
        return None;
    }
    
    let s = String::from_utf8_lossy(buffer);
    
    // Check format
    if s.len() < 16 || !s.is_ascii() {
        return None;
    }
    
    // Parse components
    let year = s[0..4].parse::<u32>().ok()?;
    let month = s[4..6].parse::<u32>().ok()?;
    let day = s[6..8].parse::<u32>().ok()?;
    let hour = s[8..10].parse::<u32>().ok()?;
    let minute = s[10..12].parse::<u32>().ok()?;
    let second = s[12..14].parse::<u32>().ok()?;
    let _hundredths = s[14..16].parse::<u32>().ok()?;
    
    // Convert to Unix timestamp
    let days_since_epoch = (year - 1970) * 365 + (year - 1969) / 4 + days_in_month(year, month) + day - 1;
    let seconds_since_epoch = days_since_epoch * 86400 + hour * 3600 + minute * 60 + second;
    
    SystemTime::UNIX_EPOCH.checked_add(Duration::from_secs(seconds_since_epoch as u64))
}

/// Write date in ISO 9660 format
pub fn write_iso_date(buffer: &mut [u8], time: SystemTime) {
    if buffer.len() < 17 {
        return;
    }
    
    // Use Unix epoch if the time is before it
    let duration = time.duration_since(UNIX_EPOCH).unwrap_or_else(|_| Duration::from_secs(0));
    let secs = duration.as_secs();
    
    let second = (secs % 60) as u8;
    let minute = ((secs / 60) % 60) as u8;
    let hour = ((secs / 3600) % 24) as u8;
    
    // Calculate days since epoch (Jan 1, 1970)
    let days = (secs / 86400) as u32;
    
    // Simple estimate of year/month/day
    let year = 1970 + days / 365;
    let remaining_days = days % 365;
    
    // Simple month calculation (not accurate for leap years)
    let (month, day) = estimate_month_day(remaining_days, is_leap_year(year));
    
    // Format as "YYYYMMDDHHMMSSFF"
    let date_str = format!(
        "{:04}{:02}{:02}{:02}{:02}{:02}00",
        year, month, day, hour, minute, second
    );
    
    // Copy to buffer
    buffer[0..16].copy_from_slice(date_str.as_bytes());
    
    // Timezone offset (byte 16): 0 = GMT
    buffer[16] = 0;
}

/// Check if a year is a leap year
fn is_leap_year(year: u32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

/// Calculate days in month
fn days_in_month(year: u32, month: u32) -> u32 {
    let days_before_month = match month {
        1 => 0,
        2 => 31,
        3 => 59,
        4 => 90,
        5 => 120,
        6 => 151,
        7 => 181,
        8 => 212,
        9 => 243,
        10 => 273,
        11 => 304,
        12 => 334,
        _ => 0,
    };
    
    // Add leap day if needed
    if month > 2 && is_leap_year(year) {
        days_before_month + 1
    } else {
        days_before_month
    }
}

/// Estimate month and day from days since start of year
fn estimate_month_day(days_since_start_of_year: u32, is_leap: bool) -> (u32, u32) {
    let days_in_month = [
        31, if is_leap { 29 } else { 28 }, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    ];
    
    let mut remaining_days = days_since_start_of_year;
    let mut month = 1;
    
    for &days in &days_in_month {
        if remaining_days < days {
            return (month, remaining_days + 1);
        }
        
        remaining_days -= days;
        month += 1;
    }
    
    // Default to December 31 if something went wrong
    (12, 31)
}
$$--GLUE--$$
.\crates\isopod\src\volume.rs
$$--GLUE--$$
use std::io::{Seek, SeekFrom, Write};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::constants::{volume_type, ISO_STANDARD_ID, SECTOR_SIZE};
use crate::directory::{Directory, DirectoryEntry};
use crate::utils;
use crate::Error;
use crate::Result;

/// A trait for volume descriptors in ISO 9660
pub trait VolumeDescriptor {
  /// Write the volume descriptor to the given writer
  fn write_to<W: Write + Seek>(&self, writer: &mut W) -> Result<()>;
}

/// Primary Volume Descriptor as defined in ISO 9660
#[derive(Debug, Clone)]
pub struct PrimaryVolumeDescriptor {
  /// Volume identifier
  volume_id: String,

  /// Publisher identifier
  publisher_id: String,

  /// Data preparer identifier
  preparer_id: String,

  /// Application identifier
  application_id: String,

  /// Volume creation date/time
  creation_time: SystemTime,

  /// Volume modification date/time
  modification_time: SystemTime,

  /// Root directory entry
  root_directory_entry: DirectoryEntry,

  /// Volume space size (in sectors)
  volume_space_size: u32,

  /// Block size (usually 2048)
  block_size: u16,

  /// Path table size in bytes
  path_table_size: u32,

  /// Location of the L path table
  path_table_location_l: u32,

  /// Location of the optional L path table
  optional_path_table_location_l: u32,

  /// Location of the M path table
  path_table_location_m: u32,

  /// Location of the optional M path table
  optional_path_table_location_m: u32,
}

impl PrimaryVolumeDescriptor {
  /// Create a new primary volume descriptor
  pub fn new(
    volume_id: &str,
    publisher_id: &str,
    preparer_id: &str,
    application_id: &str,
    root_directory: &Directory,
  ) -> Self {
    let now = SystemTime::now();

    // Create root directory entry
    let root_directory_entry = DirectoryEntry::new_directory(
      root_directory.name(),
      0, // Will be updated later
      0, // Will be updated later
    );

    // Calculate path table locations
    // Type L path table (little endian) - typically at sector 18
    let path_table_location_l = 18;

    // Optional Type L path table
    let optional_path_table_location_l = 0;

    // Type M path table (big endian) - typically at sector 19
    let path_table_location_m = 19;

    // Optional Type M path table
    let optional_path_table_location_m = 0;

    // Size for just root directory
    let path_table_size = 10;

    Self {
      volume_id: volume_id.to_string(),
      publisher_id: publisher_id.to_string(),
      preparer_id: preparer_id.to_string(),
      application_id: application_id.to_string(),
      creation_time: now,
      modification_time: now,
      root_directory_entry,
      volume_space_size: 0, // Will be calculated during write
      block_size: SECTOR_SIZE as u16,
      path_table_size: 0,       // Will be calculated during write
      path_table_location_l: 0, // Will be set during write
      optional_path_table_location_l: 0,
      path_table_location_m: 0, // Will be set during write
      optional_path_table_location_m: 0,
    }
  }

  /// Parse a primary volume descriptor from a buffer
  pub fn parse_from_buffer(buffer: &[u8]) -> Option<Self> {
    for sector in 0..16 {
      let offset = sector * SECTOR_SIZE;

      // Check if we have a primary volume descriptor
      if offset + 7 <= buffer.len()
        && buffer[offset] == volume_type::PRIMARY_VOLUME_DESCRIPTOR
        && &buffer[offset + 1..offset + 6] == ISO_STANDARD_ID
      {
        // Parse fields
        let volume_id = utils::parse_iso_string(&buffer[offset + 40..offset + 40 + 32]);
        let publisher_id = utils::parse_iso_string(&buffer[offset + 318..offset + 318 + 128]);
        let preparer_id = utils::parse_iso_string(&buffer[offset + 446..offset + 446 + 128]);
        let application_id = utils::parse_iso_string(&buffer[offset + 574..offset + 574 + 128]);

        // Parse dates
        let creation_time = utils::parse_iso_date(&buffer[offset + 813..offset + 813 + 17])
          .unwrap_or_else(|| SystemTime::now());
        let modification_time = utils::parse_iso_date(&buffer[offset + 830..offset + 830 + 17])
          .unwrap_or_else(|| SystemTime::now());

        // Parse sizes and locations
        let volume_space_size = utils::parse_u32_both(&buffer[offset + 80..offset + 80 + 8]);
        let block_size = utils::parse_u16_both(&buffer[offset + 128..offset + 128 + 4]);
        let path_table_size = utils::parse_u32_both(&buffer[offset + 132..offset + 132 + 8]);
        let path_table_location_l = u32::from_le_bytes([
          buffer[offset + 140],
          buffer[offset + 141],
          buffer[offset + 142],
          buffer[offset + 143],
        ]);
        let optional_path_table_location_l = u32::from_le_bytes([
          buffer[offset + 144],
          buffer[offset + 145],
          buffer[offset + 146],
          buffer[offset + 147],
        ]);
        let path_table_location_m = u32::from_be_bytes([
          buffer[offset + 148],
          buffer[offset + 149],
          buffer[offset + 150],
          buffer[offset + 151],
        ]);
        let optional_path_table_location_m = u32::from_be_bytes([
          buffer[offset + 152],
          buffer[offset + 153],
          buffer[offset + 154],
          buffer[offset + 155],
        ]);

        // Parse root directory entry
        let root_directory_entry =
          DirectoryEntry::parse_from_buffer(&buffer[offset + 156..offset + 156 + 34])
            .unwrap_or_else(|| DirectoryEntry::new_directory("ROOT", 0, 0));

        return Some(Self {
          volume_id,
          publisher_id,
          preparer_id,
          application_id,
          creation_time,
          modification_time,
          root_directory_entry,
          volume_space_size,
          block_size,
          path_table_size,
          path_table_location_l,
          optional_path_table_location_l,
          path_table_location_m,
          optional_path_table_location_m,
        });
      }
    }

    None
  }

  /// Get the volume ID
  pub fn volume_id(&self) -> &str {
    &self.volume_id
  }

  /// Set the volume ID
  pub fn set_volume_id(&mut self, volume_id: String) {
    self.volume_id = volume_id;
  }

  /// Get the publisher ID
  pub fn publisher_id(&self) -> &str {
    &self.publisher_id
  }

  /// Set the publisher ID
  pub fn set_publisher_id(&mut self, publisher_id: String) {
    self.publisher_id = publisher_id;
  }

  /// Get the preparer ID
  pub fn preparer_id(&self) -> &str {
    &self.preparer_id
  }

  /// Set the preparer ID
  pub fn set_preparer_id(&mut self, preparer_id: String) {
    self.preparer_id = preparer_id;
  }

  /// Get the application ID
  pub fn application_id(&self) -> &str {
    &self.application_id
  }

  /// Set the application ID
  pub fn set_application_id(&mut self, application_id: String) {
    self.application_id = application_id;
  }

  /// Get the creation time
  pub fn creation_time(&self) -> SystemTime {
    self.creation_time
  }

  /// Set the creation time
  pub fn set_creation_time(&mut self, time: SystemTime) {
    self.creation_time = time;
  }

  /// Get the modification time
  pub fn modification_time(&self) -> SystemTime {
    self.modification_time
  }

  /// Set the modification time
  pub fn set_modification_time(&mut self, time: SystemTime) {
    self.modification_time = time;
  }

  /// Get the root directory entry
  pub fn root_directory_entry(&self) -> &DirectoryEntry {
    &self.root_directory_entry
  }

  /// Get a mutable reference to the root directory entry
  pub fn root_directory_entry_mut(&mut self) -> &mut DirectoryEntry {
    &mut self.root_directory_entry
  }

  /// Get the volume space size (in sectors)
  pub fn volume_space_size(&self) -> u32 {
    self.volume_space_size
  }

  /// Set the volume space size
  pub fn set_volume_space_size(&mut self, size: u32) {
    self.volume_space_size = size;
  }

  /// Get the block size
  pub fn block_size(&self) -> u16 {
    self.block_size
  }

  /// Update volume descriptor with directory information
  pub fn update_with_directory(&mut self, root_dir: &Directory) {
    // Update root directory entry
    self.root_directory_entry = root_dir.to_entry();
  }
}

impl VolumeDescriptor for PrimaryVolumeDescriptor {
  fn write_to<W: Write + Seek>(&self, writer: &mut W) -> Result<()> {
    // Position at the 16th sector (after system area)
    let sector_position = SECTOR_SIZE as u64 * 16;
    writer.seek(SeekFrom::Start(sector_position))?;

    let mut buffer = [0u8; SECTOR_SIZE];

    // Type code
    buffer[0] = volume_type::PRIMARY_VOLUME_DESCRIPTOR;

    // Standard identifier
    buffer[1..6].copy_from_slice(ISO_STANDARD_ID);

    // Version
    buffer[6] = 1;

    // Unused field
    buffer[7] = 0;

    // System identifier (32 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[8..40], "");

    // Volume identifier (32 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[40..72], &self.volume_id);

    // Unused field (8 bytes)
    // buffer[72..80] already zeroed

    // Volume space size (both little and big endian)
    utils::write_u32_both(&mut buffer[80..88], self.volume_space_size);

    // Unused field (32 bytes)
    // buffer[88..120] already zeroed

    // Volume set size (both little and big endian)
    utils::write_u16_both(&mut buffer[120..124], 1);

    // Volume sequence number (both little and big endian)
    utils::write_u16_both(&mut buffer[124..128], 1);

    // Logical block size (both little and big endian)
    utils::write_u16_both(&mut buffer[128..132], self.block_size);

    // Path table size (both little and big endian)
    utils::write_u32_both(&mut buffer[132..140], self.path_table_size);

    // Path table locations
    buffer[140..144].copy_from_slice(&self.path_table_location_l.to_le_bytes());
    buffer[144..148].copy_from_slice(&self.optional_path_table_location_l.to_le_bytes());
    buffer[148..152].copy_from_slice(&self.path_table_location_m.to_be_bytes());
    buffer[152..156].copy_from_slice(&self.optional_path_table_location_m.to_be_bytes());

    // Root directory entry needs more space (40 bytes instead of 34)
    let mut root_dir_buffer = vec![0u8; 40];
    self
      .root_directory_entry
      .write_to_buffer(&mut root_dir_buffer[0..40])?;
    buffer[156..196].copy_from_slice(&root_dir_buffer[0..40]);

    // Volume set identifier (128 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[196..324], ""); // Changed from 190..318 to 196..324

    // Publisher identifier (128 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[324..452], &self.publisher_id); // Adjusted by +6

    // Data preparer identifier (128 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[452..580], &self.preparer_id); // Adjusted by +6

    // Application identifier (128 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[580..708], &self.application_id); // Adjusted by +6

    // Copyright file identifier (38 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[708..746], ""); // Adjusted by +6

    // Abstract file identifier (36 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[746..782], ""); // Adjusted by +6

    // Bibliographic file identifier (37 bytes, padded with spaces)
    utils::write_iso_string(&mut buffer[782..819], ""); // Adjusted by +6

    // Volume creation date/time (17 bytes)
    utils::write_iso_date(&mut buffer[819..836], self.creation_time); // Adjusted by +6

    // Volume modification date/time (17 bytes)
    utils::write_iso_date(&mut buffer[836..853], self.modification_time); // Adjusted by +6

    // Volume expiration date/time (17 bytes)
    utils::write_iso_date(&mut buffer[853..870], SystemTime::UNIX_EPOCH); // Adjusted by +6

    // Volume effective date/time (17 bytes)
    utils::write_iso_date(&mut buffer[870..887], self.creation_time); // Adjusted by +6

    // File structure version
    buffer[887] = 1; // Adjusted by +6

    // Reserved for future (1 byte)
    buffer[888] = 0; // Adjusted by +6

    // Application use (512 bytes)
    // buffer[883..1395] already zeroed

    // Reserved for future (653 bytes)
    // buffer[1395..2048] already zeroed

    writer.write_all(&buffer)?;

    Ok(())
  }
}

$$--GLUE--$$
.\crates\isopod-cli\Cargo.toml
$$--GLUE--$$
[package]
name = "isopod-cli"
version = "0.1.0"
edition = "2021"
license = "MIT"
description = "Command-line interface for the isopod ISO 9660 library"
authors = ["Maxine DeAndrade"]
repository = "https://github.com/maxine-deandrade/isopod"
keywords = ["iso", "iso9660", "filesystem", "cd", "dvd"]
categories = ["filesystem", "command-line-utilities"]

[dependencies]
isopod = { path = "../isopod", version = "0.1.0" }
clap = { version = "4.3", features = ["derive"] }
anyhow = "1.0"
env_logger = "0.10"
log = "0.4"
chrono = "0.4"
walkdir = "2.3"
indicatif = "0.17"
$$--GLUE--$$
.\crates\isopod-cli\README.md
$$--GLUE--$$
# isopod-cli

Command-line interface for the isopod ISO 9660 library.

## Installation

### From crates.io

```bash
cargo install isopod-cli
```

### From source

```bash
git clone https://github.com/meowesque/isopod.git
cd isopod
cargo install --path crates/isopod-cli
```

## Usage

### Creating an ISO

Create a new ISO image containing files and directories:

```bash
isopod create --output my_image.iso --volume-id MY_VOLUME path/to/files
```

Options:
- `--output`, `-o`: Output ISO file path (required)
- `--volume-id`, `-i`: Volume identifier (default: "ISO_VOLUME")
- `--publisher`, `-p`: Publisher identifier
- `--preparer`, `-r`: Data preparer identifier
- `--joliet`: Enable Joliet extension for long filenames
- `--rock-ridge`: Enable Rock Ridge extension for POSIX filesystem features
- `--el-torito`: Enable El Torito extension for bootable CDs
- `--udf`: Enable UDF bridge
- `--verbose`, `-v`: Enable verbose output

Example with multiple options:

```bash
isopod create --output my_image.iso \
  --volume-id "MY_VOLUME" \
  --publisher "My Organization" \
  --preparer "isopod" \
  --joliet \
  --verbose \
  path/to/files
```

### Extracting Files

Extract files from an ISO image:

```bash
# Extract all files
isopod extract --input my_image.iso --output extracted/

# Extract specific files
isopod extract --input my_image.iso --output extracted/ file1.txt docs/file2.txt
```

Options:
- `--input`, `-i`: Input ISO file path (required)
- `--output`, `-o`: Output directory (default: current directory)
- `--verbose`, `-v`: Enable verbose output

### Listing Contents

List contents of an ISO image:

```bash
isopod list my_image.iso

# With detailed information
isopod list --verbose my_image.iso
```

Options:
- `--verbose`, `-v`: Show detailed information (file sizes, dates)

### Showing ISO Information

Show detailed information about an ISO image:

```bash
isopod info my_image.iso
```

This command displays:
- Volume ID, publisher, preparer, application
- File and directory counts
- Total data size
- Enabled extensions

### Checking ISO Validity

Check the validity of an ISO image:

```bash
isopod check my_image.iso
```

This command verifies:
- ISO 9660 structure correctness
- Volume descriptor validity
- Path table correctness
- Directory records integrity

## Examples

### Creating a bootable ISO

```bash
isopod create --output bootable.iso \
  --volume-id "BOOT_DISK" \
  --el-torito \
  boot_files/
```

### Creating an ISO with unicode filenames

```bash
isopod create --output unicode.iso \
  --volume-id "UNICODE" \
  --joliet \
  files_with_unicode_names/
```

### Extracting specific files maintaining directory structure

```bash
isopod extract --input archive.iso \
  --output extracted/ \
  docs/manual.pdf \
  images/logo.png
```

## Exit Codes

- `0`: Success
- `1`: Error

## Reporting Issues

If you encounter any problems or have suggestions, please open an issue on the GitHub repository:

https://github.com/maxine-deandrade/isopod/issues
$$--GLUE--$$
.\crates\isopod-cli\src\main.rs
$$--GLUE--$$
use std::path::{Path, PathBuf};
use std::process;

use anyhow::{Result, Context, bail};
use clap::{Parser, Subcommand};
use indicatif::{ProgressBar, ProgressStyle};
use log::{info, error, warn, debug};
use walkdir::WalkDir;

use isopod::{Iso, IsoBuilder};

/// Command-line interface for isopod ISO library
#[derive(Parser)]
#[clap(
    name = "isopod",
    about = "Create and manipulate ISO 9660 filesystem images",
    version,
    author
)]
struct Cli {
    /// Enable verbose output
    #[clap(short, long)]
    verbose: bool,
    
    /// Subcommand to execute
    #[clap(subcommand)]
    command: Command,
}

/// Available commands
#[derive(Subcommand)]
enum Command {
    /// Create a new ISO image
    Create {
        /// Output ISO file
        #[clap(short, long)]
        output: PathBuf,
        
        /// Volume ID
        #[clap(short = 'i', long, default_value = "ISO_VOLUME")]
        volume_id: String,
        
        /// Publisher ID
        #[clap(short, long)]
        publisher: Option<String>,
        
        /// Data preparer
        #[clap(short = 'r', long)]
        preparer: Option<String>,
        
        /// Input directory or files to include
        #[clap(required = true)]
        input: Vec<PathBuf>,
        
        /// Enable Joliet extension for long filenames
        #[clap(long)]
        joliet: bool,
        
        /// Enable Rock Ridge extension for POSIX filesystem features
        #[clap(long)]
        rock_ridge: bool,
        
        /// Enable El Torito extension for bootable CDs
        #[clap(long)]
        el_torito: bool,
        
        /// Enable UDF bridge
        #[clap(long)]
        udf: bool,
    },
    
    /// Extract files from an ISO image
    Extract {
        /// Input ISO file
        #[clap(short, long)]
        input: PathBuf,
        
        /// Output directory
        #[clap(short, long, default_value = ".")]
        output: PathBuf,
        
        /// Specific files to extract
        files: Vec<String>,
    },
    
    /// List contents of an ISO image
    List {
        /// Input ISO file
        input: PathBuf,
        
        /// Show detailed information
        #[clap(short, long)]
        verbose: bool,
    },
    
    /// Show information about an ISO image
    Info {
        /// Input ISO file
        input: PathBuf,
    },
    
    /// Check the validity of an ISO image
    Check {
        /// Input ISO file
        input: PathBuf,
    },
}

fn main() {
    // Parse command-line arguments
    let cli = Cli::parse();
    
    // Initialize logger
    init_logger(cli.verbose);
    
    // Execute command
    if let Err(err) = run_command(cli.command) {
        error!("Error: {}", err);
        
        // Add more context to the error if possible
        if let Some(source) = err.source() {
            error!("Caused by: {}", source);
        }
        
        process::exit(1);
    }
}

/// Initialize the logger
fn init_logger(verbose: bool) {
    let env = env_logger::Env::default()
        .filter_or("RUST_LOG", if verbose { "debug" } else { "info" });
    
    let _ = env_logger::try_init_from_env(env);
}

/// Run the selected command
fn run_command(command: Command) -> Result<()> {
    match command {
        Command::Create { 
            output, 
            volume_id, 
            publisher, 
            preparer, 
            input, 
            joliet, 
            rock_ridge, 
            el_torito, 
            udf 
        } => {
            create_iso(output, volume_id, publisher, preparer, input, joliet, rock_ridge, el_torito, udf)
        },
        Command::Extract { input, output, files } => {
            extract_from_iso(input, output, files)
        },
        Command::List { input, verbose } => {
            list_iso_contents(input, verbose)
        },
        Command::Info { input } => {
            show_iso_info(input)
        },
        Command::Check { input } => {
            check_iso(input)
        },
    }
}

/// Create a new ISO image
fn create_iso(
    output: PathBuf,
    volume_id: String,
    publisher: Option<String>,
    preparer: Option<String>,
    input: Vec<PathBuf>,
    joliet: bool,
    rock_ridge: bool,
    el_torito: bool,
    udf: bool,
) -> Result<()> {
    info!("Creating ISO image: {}", output.display());
    
    // Validate inputs
    if input.is_empty() {
        bail!("No input files or directories specified");
    }
    
    // Check if we can write to the output path
    if let Some(parent) = output.parent() {
        if !parent.exists() {
            std::fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create output directory: {}", parent.display()))?;
        }
    }
    
    // Build ISO
    info!("Setting up ISO builder");
    let mut builder = Iso::builder()
        .volume_id(volume_id)
        .joliet(joliet)
        .rock_ridge(rock_ridge)
        .el_torito(el_torito)
        .udf(udf);
    
    if let Some(publisher) = publisher {
        builder = builder.publisher(publisher);
    }
    
    if let Some(preparer) = preparer {
        builder = builder.preparer(preparer);
    }
    
    info!("Creating ISO structure");
    let mut iso = builder.build()
        .with_context(|| "Failed to create ISO structure")?;
    
    // Add files and directories
    let progress = create_progress_bar("Adding files");
    
    let mut found_files = false;
    for path in input {
        debug!("Processing input path: {}", path.display());
        
        // Handle wildcard paths by expanding them
        if path.to_string_lossy().contains('*') {
            debug!("Wildcard path detected: {}", path.display());
            
            // Get the parent directory of the wildcard
            let parent = match path.parent() {
                Some(p) if p.as_os_str().is_empty() => Path::new("."),
                Some(p) => p,
                None => Path::new("."),
            };
            
            // Get the filename pattern
            let pattern = match path.file_name() {
                Some(name) => name.to_string_lossy().to_string(),
                None => continue,
            };
            
            debug!("Wildcard parent: {}, pattern: {}", parent.display(), pattern);
            
            // List all files in parent and match against pattern
            if let Ok(entries) = std::fs::read_dir(parent) {
                for entry in entries.flatten() {
                    let entry_path = entry.path();
                    let name = match entry_path.file_name() {
                        Some(name) => name.to_string_lossy().to_string(),
                        None => continue,
                    };
                    
                    // Simple wildcard matching
                    if matches_wildcard(&name, &pattern) {
                        debug!("Wildcard match: {}", entry_path.display());
                        if let Err(e) = add_files_to_iso(&mut iso, &entry_path, &entry_path, &progress) {
                            warn!("Error adding {}: {}", entry_path.display(), e);
                        } else {
                            found_files = true;
                        }
                    }
                }
            }
        } else {
            // Regular path
            if let Err(e) = add_files_to_iso(&mut iso, &path, &path, &progress) {
                warn!("Error adding {}: {}", path.display(), e);
            } else {
                found_files = true;
            }
        }
    }
    
    if !found_files {
        bail!("No valid files found to add to the ISO");
    }
    
    progress.finish_with_message("Files added");
    
    // Save ISO
    info!("Writing ISO image to disk");
    let save_progress = create_progress_bar("Writing ISO");
    save_progress.set_message(format!("Writing to {}", output.display()));
    
    match iso.save(&output) {
        Ok(_) => {
            save_progress.finish_with_message(format!("ISO created: {}", output.display()));
            Ok(())
        },
        Err(e) => {
            save_progress.finish_with_message("Failed to write ISO");
            Err(e).with_context(|| format!("Failed to write ISO to {}", output.display()))
        }
    }
}

/// Simple wildcard pattern matching
fn matches_wildcard(name: &str, pattern: &str) -> bool {
    let pattern_parts: Vec<&str> = pattern.split('*').collect();
    
    // If the pattern doesn't contain wildcard, just compare directly
    if pattern_parts.len() == 1 {
        return name == pattern;
    }
    
    // Check if name starts with the first part (if not empty)
    if !pattern_parts[0].is_empty() && !name.starts_with(pattern_parts[0]) {
        return false;
    }
    
    // Check if name ends with the last part (if not empty)
    if !pattern_parts.last().unwrap().is_empty() && !name.ends_with(pattern_parts.last().unwrap()) {
        return false;
    }
    
    // For middle parts, check if they appear in order
    let mut remaining = name;
    for &part in &pattern_parts[..pattern_parts.len() - 1] {
        if part.is_empty() {
            continue;
        }
        
        match remaining.find(part) {
            Some(pos) => {
                remaining = &remaining[pos + part.len()..];
            },
            None => return false,
        }
    }
    
    true
}


/// Add files to the ISO
fn add_files_to_iso(
    iso: &mut Iso,
    base_path: &Path,
    current_path: &Path,
    progress: &ProgressBar,
) -> Result<()> {
    // Check if the path exists
    if !current_path.exists() {
        warn!("Path does not exist: {}", current_path.display());
        return Ok(());
    }
    
    if current_path.is_dir() {
        // Create the directory in the ISO (if not root)
        if current_path != base_path {
            let rel_path = match current_path.strip_prefix(base_path) {
                Ok(path) => path,
                Err(_) => {
                    // This can happen with wildcards or special characters
                    // In this case, just use the filename part
                    match current_path.file_name() {
                        Some(name) => Path::new(name),
                        None => {
                            warn!("Could not determine relative path for: {}", current_path.display());
                            return Ok(());
                        }
                    }
                }
            };
            
            progress.set_message(format!("Adding directory {}", rel_path.display()));
            iso.add_directory(rel_path)?;
        }
        
        // Add all files and subdirectories
        match std::fs::read_dir(current_path) {
            Ok(entries) => {
                for entry_result in entries {
                    match entry_result {
                        Ok(entry) => {
                            let path = entry.path();
                            if let Err(e) = add_files_to_iso(iso, base_path, &path, progress) {
                                warn!("Error adding {}: {}", path.display(), e);
                            }
                        },
                        Err(e) => {
                            warn!("Error reading directory entry: {}", e);
                        }
                    }
                }
            },
            Err(e) => {
                warn!("Error reading directory {}: {}", current_path.display(), e);
            }
        }
    } else if current_path.is_file() {
        // Add file to ISO
        let rel_path = match current_path.strip_prefix(base_path) {
            Ok(path) => path,
            Err(_) => {
                // This can happen with wildcards or special characters
                // In this case, just use the filename part
                match current_path.file_name() {
                    Some(name) => Path::new(name),
                    None => {
                        warn!("Could not determine relative path for: {}", current_path.display());
                        return Ok(());
                    }
                }
            }
        };
        
        progress.set_message(format!("Adding file {}", rel_path.display()));
        progress.inc(1);
        
        match iso.add_file(rel_path, current_path) {
            Ok(_) => {},
            Err(e) => {
                warn!("Error adding file {}: {}", current_path.display(), e);
            }
        }
    }
    
    Ok(())
}

/// Extract files from an ISO
fn extract_from_iso(
    input: PathBuf,
    output: PathBuf,
    files: Vec<String>,
) -> Result<()> {
    info!("Extracting from ISO: {}", input.display());
    
    // Create output directory if it doesn't exist
    if !output.exists() {
        std::fs::create_dir_all(&output)?;
    }
    
    // Open ISO
    let iso = Iso::open(&input)?;
    
    // Extract files
    let progress = create_progress_bar("Extracting files");
    
    if files.is_empty() {
        // Extract all files
        extract_directory(
            iso.root_directory(), 
            &output, 
            &PathBuf::new(),
            &progress
        )?;
    } else {
        // Extract specific files
        for file_path in files {
            let path = PathBuf::from(file_path);
            let target_path = output.join(&path);
            
            progress.set_message(format!("Extracting {}", path.display()));
            progress.inc(1);
            
            // Create parent directory if needed
            if let Some(parent) = target_path.parent() {
                std::fs::create_dir_all(parent)?;
            }
            
            // Extract file
            iso.extract_file(&path, &target_path)
                .with_context(|| format!("Failed to extract {}", path.display()))?;
        }
    }
    
    progress.finish_with_message("Files extracted");
    
    Ok(())
}

/// Extract a directory recursively
fn extract_directory(
    directory: &isopod::Directory,
    output_base: &Path,
    rel_path: &Path,
    progress: &ProgressBar,
) -> Result<()> {
    // Create current directory
    let current_dir = output_base.join(rel_path);
    std::fs::create_dir_all(&current_dir)?;
    
    // Extract files
    for (name, file) in directory.files() {
        let file_rel_path = rel_path.join(name);
        let file_path = output_base.join(&file_rel_path);
        
        progress.set_message(format!("Extracting {}", file_rel_path.display()));
        progress.inc(1);
        
        // Write file content
        std::fs::write(&file_path, file.content())?;
    }
    
    // Extract subdirectories
    for (name, dir) in directory.directories() {
        let dir_rel_path = rel_path.join(name);
        extract_directory(dir, output_base, &dir_rel_path, progress)?;
    }
    
    Ok(())
}

/// List contents of an ISO
fn list_iso_contents(
    input: PathBuf,
    verbose: bool,
) -> Result<()> {
    info!("Listing contents of ISO: {}", input.display());
    
    // Open ISO
    let iso = Iso::open(&input)?;
    
    // Print volume info
    println!("Volume ID: {}", iso.volume_descriptor().volume_id());
    println!("Publisher: {}", iso.volume_descriptor().publisher_id());
    println!("Preparer: {}", iso.volume_descriptor().preparer_id());
    println!("Application: {}", iso.volume_descriptor().application_id());
    println!();
    
    // Print file listing
    println!("Contents:");
    list_directory(iso.root_directory(), &PathBuf::new(), verbose, 0)?;
    
    Ok(())
}

/// List a directory recursively
fn list_directory(
    directory: &isopod::Directory,
    path: &Path,
    verbose: bool,
    indent: usize,
) -> Result<()> {
    // List files
    for (name, file) in directory.files() {
        let file_path = path.join(name);
        
        if verbose {
            println!(
                "{:indent$}{} [{} bytes]",
                "", 
                file_path.display(), 
                file.content().len(),
                indent = indent
            );
        } else {
            println!("{:indent$}{}", "", file_path.display(), indent = indent);
        }
    }
    
    // List subdirectories
    for (name, dir) in directory.directories() {
        let dir_path = path.join(name);
        
        println!("{:indent$}{}/ [directory]", "", dir_path.display(), indent = indent);
        
        // Recursively list subdirectory
        list_directory(dir, &dir_path, verbose, indent + 2)?;
    }
    
    Ok(())
}

/// Show information about an ISO
fn show_iso_info(input: PathBuf) -> Result<()> {
    info!("Showing information for ISO: {}", input.display());
    
    // Open ISO
    let iso = Iso::open(&input)?;
    
    // Print volume info
    println!("ISO 9660 Image Information");
    println!("=========================");
    println!("File: {}", input.display());
    println!("Volume ID: {}", iso.volume_descriptor().volume_id());
    println!("Publisher: {}", iso.volume_descriptor().publisher_id());
    println!("Data Preparer: {}", iso.volume_descriptor().preparer_id());
    println!("Application: {}", iso.volume_descriptor().application_id());
    
    // Print file count
    let (file_count, dir_count, total_size) = count_items(iso.root_directory());
    println!("File Count: {}", file_count);
    println!("Directory Count: {}", dir_count);
    println!("Total Data Size: {} bytes", total_size);
    
    // Print extensions
    let extensions = iso.extensions();
    println!("\nExtensions:");
    println!("  Joliet: {}", if extensions.joliet { "Yes" } else { "No" });
    println!("  Rock Ridge: {}", if extensions.rock_ridge { "Yes" } else { "No" });
    println!("  El Torito: {}", if extensions.el_torito { "Yes" } else { "No" });
    println!("  UDF: {}", if extensions.udf { "Yes" } else { "No" });
    
    Ok(())
}

/// Count items in a directory
fn count_items(directory: &isopod::Directory) -> (usize, usize, usize) {
    let mut file_count = directory.files().len();
    let mut dir_count = directory.directories().len();
    let mut total_size = directory.files().values().map(|f| f.content().len()).sum();
    
    // Recursively count subdirectories
    for subdir in directory.directories().values() {
        let (files, dirs, size) = count_items(subdir);
        file_count += files;
        dir_count += dirs;
        total_size += size;
    }
    
    (file_count, dir_count, total_size)
}

/// Check the validity of an ISO
fn check_iso(input: PathBuf) -> Result<()> {
    info!("Checking ISO: {}", input.display());
    
    // First check basic file access
    let file_size = match std::fs::metadata(&input) {
        Ok(metadata) => metadata.len(),
        Err(e) => {
            bail!("Cannot access ISO file: {}", e);
        }
    };
    
    if file_size == 0 {
        bail!("ISO file is empty");
    }
    
    info!("ISO file size: {} bytes", file_size);
    
    // Try to open and parse the ISO
    let iso = match Iso::open(&input) {
        Ok(iso) => {
            info!("Successfully parsed ISO basic structure");
            iso
        },
        Err(err) => {
            bail!("Invalid ISO format: {}", err);
        }
    };
    
    // Basic validation
    println!("ISO Check Summary");
    println!("================");
    println!("File: {}", input.display());
    println!("Size: {} bytes", file_size);
    
    let volume_id = iso.volume_descriptor().volume_id();
    println!("Volume ID: {}", volume_id);
    if volume_id.is_empty() {
        warn!("ISO has empty volume ID");
    }
    
    // Check for standard directories
    let root = iso.root_directory();
    
    // Count and validate files
    let progress = create_progress_bar("Checking files");
    progress.set_message("Scanning directory structure");
    
    let result = validate_directory(root, &PathBuf::new(), &progress);
    progress.finish_with_message("ISO check complete");
    
    // Print summary
    if let Ok((file_count, dir_count, errors)) = result {
        println!("Files found: {}", file_count);
        println!("Directories found: {}", dir_count);
        
        if errors.is_empty() {
            println!("Status: Valid (no errors found)");
        } else {
            println!("Status: Invalid ({} errors found)", errors.len());
            for error in errors {
                println!("  - {}", error);
            }
        }
    }
    
    Ok(())
}

/// Validate a directory recursively
fn validate_directory(
    directory: &isopod::Directory,
    path: &Path,
    progress: &ProgressBar,
) -> Result<(usize, usize, Vec<String>)> {
    let mut file_count = 0;
    let mut dir_count = 0;
    let mut errors = Vec::new();
    
    // Check files
    for (name, file) in directory.files() {
        let file_path = path.join(name);
        progress.set_message(format!("Checking {}", file_path.display()));
        progress.inc(1);
        
        // Basic file validation
        if name.is_empty() {
            errors.push(format!("File at {} has empty name", file_path.display()));
        }
        
        file_count += 1;
    }
    
    // Check subdirectories
    for (name, dir) in directory.directories() {
        let dir_path = path.join(name);
        
        // Basic directory validation
        if name.is_empty() {
            errors.push(format!("Directory at {} has empty name", dir_path.display()));
        }
        
        // Recursively validate subdirectory
        let (files, dirs, subdir_errors) = validate_directory(dir, &dir_path, progress)?;
        file_count += files;
        dir_count += dirs + 1;
        errors.extend(subdir_errors);
    }
    
    Ok((file_count, dir_count, errors))
}

/// Create a progress bar with the given message
fn create_progress_bar(message: &str) -> ProgressBar {
    let pb = ProgressBar::new_spinner();
    
    pb.set_style(
        ProgressStyle::default_spinner()
            .tick_chars("⠁⠂⠄⡀⢀⠠⠐⠈ ")
            .template("{spinner:.green} {msg}")
            .unwrap()
    );
    
    pb.set_message(message.to_string());
    pb.enable_steady_tick(std::time::Duration::from_millis(100));
    
    pb
}
$$--GLUE--$$
.\create_iso.bat
$$--GLUE--$$
@echo off
REM Create an ISO file with Joliet support for long filenames

REM Define source files - use a specific directory instead of wildcard 
REM to avoid including unnecessary files
set SOURCE_DIR=crates

REM Define output file
set OUTPUT_FILE=isopod-lib.iso

echo Creating ISO with Joliet support enabled...
target\debug\isopod-cli.exe create --output %OUTPUT_FILE% --volume-id "ISOPOD" --joliet %SOURCE_DIR%

echo.
if %ERRORLEVEL% EQU 0 (
    echo Success! ISO created at %OUTPUT_FILE%
) else (
    echo Failed to create ISO.
)
$$--GLUE--$$
.\rustfmt.toml
$$--GLUE--$$
tab_spaces = 2